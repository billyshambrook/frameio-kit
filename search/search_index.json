{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"frameio-kit: Build Powerful Frame.io Integrations in Minutes","text":"<p>frameio-kit is the fastest way to build robust, scalable integrations with Frame.io. Stop wrestling with webhook signatures, API authentication, and event parsing \u2013 focus on what makes your integration unique.</p>"},{"location":"#get-started-in-5-minutes","title":"\ud83d\ude80 Get Started in 5 Minutes","text":"<p>Ready to build your first Frame.io integration? Our Getting Started guide will have you up and running with both webhooks and custom actions in just a few minutes.</p> <pre><code>from frameio_kit import App, WebhookEvent, ActionEvent, Message\n\napp = App()\n\n@app.on_webhook(\"file.ready\", secret=\"your-secret\")\nasync def on_file_ready(event: WebhookEvent):\n    print(f\"File is ready!\")\n\n@app.on_action(\"my_app.analyze\", name=\"Analyze File\", description=\"Analyze this file\", secret=\"your-secret\")\nasync def analyze_file(event: ActionEvent):\n    return Message(title=\"Analysis Complete\", description=\"File analyzed successfully!\")\n</code></pre>"},{"location":"#why-frameio-kit","title":"\u26a1 Why frameio-kit?","text":"<ul> <li>Decorator-based routing - <code>@app.on_webhook</code> and <code>@app.on_action</code> make event handling trivial</li> <li>Automatic validation - Pydantic models give you full type safety and editor support</li> <li>Modern Python - Built for Python 3.13+ with full type hints</li> <li>Secure by default - Built-in signature verification for all requests</li> <li>Error handling - Graceful failure handling and retry logic</li> </ul>"},{"location":"#what-can-you-build","title":"\ud83c\udfaf What Can You Build?","text":""},{"location":"#automated-workflows","title":"Automated Workflows","text":"<ul> <li>File processing pipelines - Automatically process videos, images, and documents</li> <li>Content moderation - Scan and approve content before publication</li> <li>Asset management - Organize, tag, and categorize your media library</li> </ul>"},{"location":"#interactive-tools","title":"Interactive Tools","text":"<ul> <li>Custom actions - Build right-click menu items that do exactly what you need</li> <li>User forms - Collect input with interactive forms in the Frame.io UI</li> <li>Real-time notifications - Keep teams updated with instant alerts</li> </ul>"},{"location":"#api-integrations","title":"API Integrations","text":"<ul> <li>Third-party services - Connect Frame.io to your favorite tools</li> <li>Data synchronization - Keep external systems in sync with Frame.io</li> <li>Custom dashboards - Build analytics and reporting tools</li> </ul>"},{"location":"#learn-more","title":"\ud83d\udcda Learn More","text":""},{"location":"#core-concepts","title":"Core Concepts","text":"<ul> <li>App Configuration - Configure middleware, OAuth, and dynamic secret resolution</li> <li>Webhooks - React to Frame.io events automatically</li> <li>Custom Actions - Build interactive user experiences</li> <li>Client API - Make calls back to Frame.io's API</li> <li>Middleware - Add cross-cutting concerns to your integration</li> <li>User Authentication - Enable Adobe Login OAuth for user-specific actions</li> </ul>"},{"location":"#advanced-features","title":"Advanced Features","text":"<ul> <li>Installation System - Self-service installation pages for workspace admins with branded UI</li> <li>Mounting to Existing Apps - Integrate with FastAPI, Starlette, or any ASGI framework</li> <li>API Reference - Complete documentation for all classes and methods</li> <li>Type safety - Full Pydantic models for all event types</li> <li>Async patterns - Best practices for high-performance integrations</li> </ul>"},{"location":"#quick-examples","title":"\ud83d\udee0\ufe0f Quick Examples","text":""},{"location":"#file-processing-pipeline","title":"File Processing Pipeline","text":"<pre><code>from frameio import CreateCommentParamsData\n\n@app.on_webhook(\"file.ready\", secret=os.environ[\"WEBHOOK_SECRET\"])\nasync def process_file(event: WebhookEvent):\n    # Get file details\n    file = await app.client.files.show(\n        account_id=event.account_id,\n        file_id=event.resource_id,\n    )\n\n    # Process the file\n    result = await my_processing_service.process(file)\n\n    # Add a comment back to Frame.io\n    await app.client.comments.create(\n        account_id=event.account_id,\n        file_id=event.resource_id,\n        data=CreateCommentParamsData(text=f\"Processing complete! Result: {result}\")\n    )\n</code></pre>"},{"location":"#interactive-custom-action","title":"Interactive Custom Action","text":"<pre><code>@app.on_action(\"asset.publish\", name=\"Publish Asset\", description=\"Publish to social media\", secret=os.environ[\"ACTION_SECRET\"])\nasync def publish_asset(event: ActionEvent):\n    if event.data:\n        # Form was submitted\n        platform = event.data.get(\"platform\")\n        caption = event.data.get(\"caption\")\n\n        # Publish the asset\n        await publish_to_social_media(event.resource_id, platform, caption)\n\n        return Message(title=\"Published!\", description=f\"Posted to {platform}\")\n\n    # Show the form\n    return Form(\n        title=\"Publish to Social Media\",\n        description=\"Choose where to publish:\",\n        fields=[\n            SelectField(label=\"Platform\", name=\"platform\", options=PLATFORMS),\n            TextField(label=\"Caption\", name=\"caption\", value=\"Enter your caption...\")\n        ]\n    )\n</code></pre>"},{"location":"#ready-to-build","title":"\ud83c\udf89 Ready to Build?","text":"<ol> <li>Start with our Getting Started guide - Get up and running in minutes</li> <li>Explore the Usage Guides - Learn about webhooks, actions, and more</li> <li>Check out the API reference - Complete documentation</li> <li>Build something amazing - The only limit is your imagination!</li> </ol> <p>frameio-kit - Because building Frame.io integrations should be fun, not frustrating. \ud83d\ude80</p>"},{"location":"api_reference/","title":"API Reference","text":"<p>This section provides a detailed API reference for all public classes, methods, and functions in the <code>frameio-kit</code> library.</p>"},{"location":"api_reference/#frameio_kit","title":"frameio_kit","text":"<p>Classes:</p> <ul> <li> <code>App</code>           \u2013            <p>The main application class for building Frame.io integrations.</p> </li> <li> <code>Client</code>           \u2013            <p>Asynchronous HTTP client for interacting with the Frame.io v4 API.</p> </li> <li> <code>Account</code>           \u2013            <p>Represents the account context, used in standard webhook payloads.</p> </li> <li> <code>ActionEvent</code>           \u2013            <p>A custom action event payload, including user-submitted form data.</p> </li> <li> <code>Project</code>           \u2013            <p>Represents the project context in which an event occurred.</p> </li> <li> <code>Resource</code>           \u2013            <p>Represents the primary resource that an event pertains to.</p> </li> <li> <code>User</code>           \u2013            <p>Represents the user who initiated the event.</p> </li> <li> <code>WebhookEvent</code>           \u2013            <p>A standard webhook event payload from Frame.io.</p> </li> <li> <code>Workspace</code>           \u2013            <p>Represents the workspace (formerly Team) in which an event occurred.</p> </li> <li> <code>ConfigurationError</code>           \u2013            <p>Raised when application configuration is invalid.</p> </li> <li> <code>EventValidationError</code>           \u2013            <p>Raised when event payload validation fails.</p> </li> <li> <code>FrameioKitError</code>           \u2013            <p>Base exception for all Frame.io Kit errors.</p> </li> <li> <code>InstallationError</code>           \u2013            <p>Base exception for installation-related errors.</p> </li> <li> <code>InstallationNotFoundError</code>           \u2013            <p>No installation found for the given workspace.</p> </li> <li> <code>OAuthError</code>           \u2013            <p>Base exception for OAuth-related errors.</p> </li> <li> <code>SecretResolutionError</code>           \u2013            <p>Raised when secret resolution fails.</p> </li> <li> <code>SignatureVerificationError</code>           \u2013            <p>Raised when request signature verification fails.</p> </li> <li> <code>TokenExchangeError</code>           \u2013            <p>Raised when OAuth token exchange fails.</p> </li> <li> <code>TokenRefreshError</code>           \u2013            <p>Raised when OAuth token refresh fails.</p> </li> <li> <code>Middleware</code>           \u2013            <p>Base class for creating middleware in Frame.io integrations.</p> </li> <li> <code>OAuthConfig</code>           \u2013            <p>OAuth configuration for Adobe IMS authentication.</p> </li> <li> <code>MemoryStorage</code>           \u2013            <p>In-memory storage backend for development and testing.</p> </li> <li> <code>Storage</code>           \u2013            <p>Protocol for async key-value storage backends.</p> </li> <li> <code>DynamoDBStorage</code>           \u2013            <p>DynamoDB storage backend for multi-server deployments.</p> </li> <li> <code>CheckboxField</code>           \u2013            <p>A checkbox input.</p> </li> <li> <code>Form</code>           \u2013            <p>A modal with a form to collect input from the user.</p> </li> <li> <code>LinkField</code>           \u2013            <p>A non-editable field that displays a URL with a \"Copy\" button.</p> </li> <li> <code>Message</code>           \u2013            <p>A simple message modal to display information to the user.</p> </li> <li> <code>SelectField</code>           \u2013            <p>A dropdown menu allowing the user to select one from a list of options.</p> </li> <li> <code>SelectOption</code>           \u2013            <p>Represents a single choice within a <code>SelectField</code>.</p> </li> <li> <code>TextareaField</code>           \u2013            <p>A multi-line text input area, suitable for longer descriptions.</p> </li> <li> <code>TextField</code>           \u2013            <p>A single-line text input field.</p> </li> <li> <code>ActionRecord</code>           \u2013            <p>Record of a custom action created during installation.</p> </li> <li> <code>Installation</code>           \u2013            <p>Record of a complete app installation for a workspace.</p> </li> <li> <code>WebhookRecord</code>           \u2013            <p>Record of a webhook created during installation.</p> </li> </ul> <p>Functions:</p> <ul> <li> <code>get_user_token</code>             \u2013              <p>Get the authenticated user's access token.</p> </li> <li> <code>verify_signature</code>             \u2013              <p>Verifies the HMAC-SHA256 signature of an incoming Frame.io request.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>AnyEvent</code>           \u2013            <p>Union type representing any event that can be processed by the app.</p> </li> <li> <code>NextFunc</code>           \u2013            <p>Type alias for the next function in the middleware chain.</p> </li> <li> <code>AnyResponse</code>           \u2013            <p>Union type representing any response that can be returned from handlers.</p> </li> </ul>"},{"location":"api_reference/#frameio_kit.AnyEvent","title":"AnyEvent  <code>module-attribute</code>","text":"<pre><code>AnyEvent = ActionEvent | WebhookEvent\n</code></pre> <p>Union type representing any event that can be processed by the app.</p>"},{"location":"api_reference/#frameio_kit.NextFunc","title":"NextFunc  <code>module-attribute</code>","text":"<pre><code>NextFunc = Callable[[AnyEvent], Awaitable[AnyResponse]]\n</code></pre> <p>Type alias for the next function in the middleware chain.</p>"},{"location":"api_reference/#frameio_kit.AnyResponse","title":"AnyResponse  <code>module-attribute</code>","text":"<pre><code>AnyResponse = Message | Form | None\n</code></pre> <p>Union type representing any response that can be returned from handlers.</p>"},{"location":"api_reference/#frameio_kit.App","title":"App","text":"<pre><code>App(\n    *,\n    token: str | None = None,\n    api_url: str | None = None,\n    middleware: list[Middleware] | None = None,\n    oauth: OAuthConfig | None = None,\n    storage: Storage | None = None,\n    encryption_key: str | None = None,\n    install: bool = False,\n    install_session_ttl: int = 1800,\n    base_url: str | None = None,\n    allowed_accounts: list[str] | None = None,\n    name: str | None = None,\n    description: str = \"\",\n    logo_url: str | None = None,\n    primary_color: str = \"#6366f1\",\n    accent_color: str = \"#8b5cf6\",\n    custom_css: str | None = None,\n    show_powered_by: bool = True,\n)\n</code></pre> <p>The main application class for building Frame.io integrations.</p> <p>This class serves as the core of your integration. It is an ASGI-compatible application that listens for incoming HTTP POST requests from Frame.io, validates their signatures, and dispatches them to the appropriate handler functions that you register using decorators.</p> <p>Attributes:</p> <ul> <li> <code>client</code>               (<code>Client</code>)           \u2013            <p>An authenticated API client for making calls back to the Frame.io API, available if an <code>token</code> was provided.</p> </li> </ul> <p>Parameters:</p> <ul> <li> </li> <li> </li> <li> </li> <li> </li> <li> </li> <li> </li> <li> </li> <li> </li> <li> </li> <li> </li> <li> </li> <li> </li> <li> </li> <li> </li> <li> </li> <li> </li> <li> </li> </ul> <p>Methods:</p> <ul> <li> <code>validate_configuration</code>             \u2013              <p>Check configuration is valid before accepting requests.</p> </li> <li> <code>on_webhook</code>             \u2013              <p>Decorator to register a function as a webhook event handler.</p> </li> <li> <code>on_action</code>             \u2013              <p>Decorator to register a function as a custom action handler.</p> </li> <li> <code>close</code>             \u2013              <p>Close underlying HTTP clients and release resources.</p> </li> <li> <code>__call__</code>             \u2013              <p>ASGI call interface to delegate to the underlying Starlette app.</p> </li> </ul>"},{"location":"api_reference/#frameio_kit.App(token)","title":"<code>token</code>","text":"(<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>An optional access token obtained from the Adobe Developer Console. If provided, this token will be used to authenticate API calls made via the <code>app.client</code> property.</p>"},{"location":"api_reference/#frameio_kit.App(api_url)","title":"<code>api_url</code>","text":"(<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Optional base URL for the Frame.io API. Defaults to <code>https://api.frame.io</code>. Override this for testing or to target a different API environment.</p>"},{"location":"api_reference/#frameio_kit.App(middleware)","title":"<code>middleware</code>","text":"(<code>list[Middleware] | None</code>, default:                   <code>None</code> )           \u2013            <p>An optional list of middleware classes to process requests before they reach the handler.</p>"},{"location":"api_reference/#frameio_kit.App(oauth)","title":"<code>oauth</code>","text":"(<code>OAuthConfig | None</code>, default:                   <code>None</code> )           \u2013            <p>Optional OAuth configuration for user authentication. When provided, enables Adobe Login OAuth flow for actions that require user-specific authentication.</p>"},{"location":"api_reference/#frameio_kit.App(storage)","title":"<code>storage</code>","text":"(<code>Storage | None</code>, default:                   <code>None</code> )           \u2013            <p>Storage backend instance for persisting encrypted tokens and install records. If None, defaults to MemoryStorage.</p>"},{"location":"api_reference/#frameio_kit.App(encryption_key)","title":"<code>encryption_key</code>","text":"(<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Optional encryption key for token storage. If None, uses FRAMEIO_AUTH_ENCRYPTION_KEY env var or generates ephemeral key.</p>"},{"location":"api_reference/#frameio_kit.App(install)","title":"<code>install</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to enable the self-service <code>/install</code> page. Requires <code>oauth</code> to also be configured.</p>"},{"location":"api_reference/#frameio_kit.App(install_session_ttl)","title":"<code>install_session_ttl</code>","text":"(<code>int</code>, default:                   <code>1800</code> )           \u2013            <p>Install session TTL in seconds. Defaults to 30 minutes (1800).</p>"},{"location":"api_reference/#frameio_kit.App(base_url)","title":"<code>base_url</code>","text":"(<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Explicit public URL for the app. If not set, the URL is inferred from incoming requests.</p>"},{"location":"api_reference/#frameio_kit.App(allowed_accounts)","title":"<code>allowed_accounts</code>","text":"(<code>list[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>Optional list of Frame.io account IDs that are permitted to install the app. When set, only these accounts are shown in the install UI and install/uninstall requests for other accounts are rejected. When None (default), all accounts are available.</p>"},{"location":"api_reference/#frameio_kit.App(name)","title":"<code>name</code>","text":"(<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Display name shown in the install and auth UI headers. Defaults to <code>\"Authentication\"</code> when None.</p>"},{"location":"api_reference/#frameio_kit.App(description)","title":"<code>description</code>","text":"(<code>str</code>, default:                   <code>''</code> )           \u2013            <p>Description shown on the landing page.</p>"},{"location":"api_reference/#frameio_kit.App(logo_url)","title":"<code>logo_url</code>","text":"(<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>URL to the partner logo image.</p>"},{"location":"api_reference/#frameio_kit.App(primary_color)","title":"<code>primary_color</code>","text":"(<code>str</code>, default:                   <code>'#6366f1'</code> )           \u2013            <p>Hex color code for primary branding.</p>"},{"location":"api_reference/#frameio_kit.App(accent_color)","title":"<code>accent_color</code>","text":"(<code>str</code>, default:                   <code>'#8b5cf6'</code> )           \u2013            <p>Hex color code for accent/secondary highlights.</p>"},{"location":"api_reference/#frameio_kit.App(custom_css)","title":"<code>custom_css</code>","text":"(<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Raw CSS string injected into page templates.</p>"},{"location":"api_reference/#frameio_kit.App(show_powered_by)","title":"<code>show_powered_by</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to show \"Powered by frameio-kit\" footer.</p>"},{"location":"api_reference/#frameio_kit.App.client","title":"client  <code>property</code>","text":"<pre><code>client: Client\n</code></pre> <p>Provides access to an authenticated asynchronous API client.</p> <p>This client can be used within your handler functions to make calls back to the Frame.io API to fetch more information or perform actions. The client is initialized lazily on its first access.</p> Example <pre><code>@app.on_webhook(\"file.ready\", secret=\"...\")\nasync def on_file_ready(event: WebhookEvent):\n    # Use the client to fetch more details about the file\n    file_details = await app.client.files.show(account_id=event.account_id, file_id=event.resource_id)\n    print(file_details.data.name)\n</code></pre> <p>Returns:</p> <ul> <li> <code>Client</code>           \u2013            <p>An instance of Frame.io <code>Client</code>, ready to make authenticated requests.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>RuntimeError</code>             \u2013            <p>If the <code>App</code> was initialized without a <code>token</code>.</p> </li> </ul>"},{"location":"api_reference/#frameio_kit.App.token_manager","title":"token_manager  <code>property</code>","text":"<pre><code>token_manager: TokenManager\n</code></pre> <p>Provides access to the OAuth token manager.</p> <p>This manager handles encrypted token storage, retrieval, and automatic refresh for user authentication. Only available when OAuth is configured.</p> Example <pre><code># Delete a user's token (logout)\nawait app.token_manager.delete_token(user_id=\"user_123\")\n\n# Check if user has a token\ntoken = await app.token_manager.get_token(user_id=\"user_123\")\nif token:\n    print(\"User is authenticated\")\n</code></pre> <p>Returns:</p> <ul> <li> <code>TokenManager</code>           \u2013            <p>The TokenManager instance for managing user tokens.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>RuntimeError</code>             \u2013            <p>If OAuth was not configured during App initialization.</p> </li> </ul>"},{"location":"api_reference/#frameio_kit.App.validate_configuration","title":"validate_configuration","text":"<pre><code>validate_configuration() -&gt; list[str]\n</code></pre> <p>Check configuration is valid before accepting requests.</p> <p>This method validates that all registered handlers have valid configurations and that OAuth is properly set up for handlers that require user authentication.</p> <p>Returns:</p> <ul> <li> <code>list[str]</code>           \u2013            <p>List of configuration error messages. Empty list if valid.</p> </li> </ul> Example <pre><code>errors = app.validate_configuration()\nif errors:\n    for error in errors:\n        print(f\"Configuration error: {error}\")\n    sys.exit(1)\n</code></pre>"},{"location":"api_reference/#frameio_kit.App.on_webhook","title":"on_webhook","text":"<pre><code>on_webhook(\n    event_type: str | list[str],\n    secret: str | WebhookSecretResolver | None = None,\n)\n</code></pre> <p>Decorator to register a function as a webhook event handler.</p> <p>This decorator registers an asynchronous function to be called whenever Frame.io sends a webhook event of the specified type(s). A webhook handler receives a <code>WebhookEvent</code> and must return <code>None</code>.</p> Example <pre><code>from frameio_kit import App, WebhookEvent\n\napp = App()\n\n# Using explicit secret string\n@app.on_webhook(event_type=\"file.ready\", secret=\"your-secret\")\nasync def on_file_ready(event: WebhookEvent):\n    pass\n\n# Using decorator-level resolver\nasync def resolve_secret(event: WebhookEvent) -&gt; str:\n    return await db.get_secret(event.account_id)\n\n@app.on_webhook(event_type=\"file.ready\", secret=resolve_secret)\nasync def on_file_ready(event: WebhookEvent):\n    pass\n\n# Using WEBHOOK_SECRET environment variable\n@app.on_webhook(event_type=\"file.ready\")\nasync def on_another_event(event: WebhookEvent):\n    pass\n</code></pre> <p>Parameters:</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If no secret source is available (no explicit secret, no app-level resolver, and no WEBHOOK_SECRET environment variable).</p> </li> </ul>"},{"location":"api_reference/#frameio_kit.App.on_webhook(event_type)","title":"<code>event_type</code>","text":"(<code>str | list[str]</code>)           \u2013            <p>The Frame.io event type to listen for (e.g., <code>\"file.ready\"</code>). You can also provide a list of strings to register the same handler for multiple event types.</p>"},{"location":"api_reference/#frameio_kit.App.on_webhook(secret)","title":"<code>secret</code>","text":"(<code>str | WebhookSecretResolver | None</code>, default:                   <code>None</code> )           \u2013            <p>The signing secret or a resolver function. Can be: - A string: Static secret for signature verification - A callable: Async function receiving WebhookEvent and returning secret - None: Falls back to app-level resolver or WEBHOOK_SECRET env var</p>"},{"location":"api_reference/#frameio_kit.App.on_action","title":"on_action","text":"<pre><code>on_action(\n    event_type: str,\n    *,\n    name: str,\n    description: str,\n    secret: str | ActionSecretResolver | None = None,\n    require_user_auth: bool = False,\n)\n</code></pre> <p>Decorator to register a function as a custom action handler.</p> <p>This decorator connects an asynchronous function to a Custom Action in the Frame.io UI. The handler receives an <code>ActionEvent</code> and can return a <code>Message</code>, a <code>Form</code> for more input, or <code>None</code>.</p> Example <pre><code>from frameio_kit import App, ActionEvent\n\napp = App()\n\n# Using explicit secret string\n@app.on_action(\"my_app.transcribe\", name=\"Transcribe\", description=\"Transcribe file\", secret=\"your-secret\")\nasync def on_transcribe(event: ActionEvent):\n    pass\n\n# Using decorator-level resolver\nasync def resolve_secret(event: ActionEvent) -&gt; str:\n    return await db.get_secret(event.resource.id)\n\n@app.on_action(\"my_app.convert\", name=\"Convert\", description=\"Convert file\", secret=resolve_secret)\nasync def on_convert(event: ActionEvent):\n    pass\n\n# Using CUSTOM_ACTION_SECRET environment variable\n@app.on_action(\"my_app.process\", name=\"Process\", description=\"Process file\")\nasync def on_process(event: ActionEvent):\n    pass\n</code></pre> <p>Parameters:</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If no secret source is available (no explicit secret, no app-level resolver, and no CUSTOM_ACTION_SECRET environment variable).</p> </li> </ul>"},{"location":"api_reference/#frameio_kit.App.on_action(event_type)","title":"<code>event_type</code>","text":"(<code>str</code>)           \u2013            <p>A unique string you define to identify this action (e.g., <code>\"my_app.transcribe\"</code>). This is the <code>type</code> that will be present in the incoming payload.</p>"},{"location":"api_reference/#frameio_kit.App.on_action(name)","title":"<code>name</code>","text":"(<code>str</code>)           \u2013            <p>The user-visible name for the action in the Frame.io UI menu.</p>"},{"location":"api_reference/#frameio_kit.App.on_action(description)","title":"<code>description</code>","text":"(<code>str</code>)           \u2013            <p>A short, user-visible description of what the action does.</p>"},{"location":"api_reference/#frameio_kit.App.on_action(secret)","title":"<code>secret</code>","text":"(<code>str | ActionSecretResolver | None</code>, default:                   <code>None</code> )           \u2013            <p>The signing secret or a resolver function. Can be: - A string: Static secret for signature verification - A callable: Async function receiving ActionEvent and returning secret - None: Falls back to app-level resolver or CUSTOM_ACTION_SECRET env var</p>"},{"location":"api_reference/#frameio_kit.App.on_action(require_user_auth)","title":"<code>require_user_auth</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, requires user to authenticate via Adobe Login OAuth before executing the handler. OAuth must be configured in App initialization for this to work.</p>"},{"location":"api_reference/#frameio_kit.App.close","title":"close  <code>async</code>","text":"<pre><code>close() -&gt; None\n</code></pre> <p>Close underlying HTTP clients and release resources.</p> <p>Call this when shutting down the application to cleanly close connections. When running standalone with uvicorn this is handled automatically via the ASGI lifespan. When mounting inside another framework (e.g. FastAPI) you should call this from the parent app's lifespan shutdown.</p> Example <pre><code>from contextlib import asynccontextmanager\nfrom fastapi import FastAPI\n\n@asynccontextmanager\nasync def lifespan(app):\n    yield\n    await frameio_app.close()\n\napp = FastAPI(lifespan=lifespan)\napp.mount(\"/\", frameio_app)\n</code></pre>"},{"location":"api_reference/#frameio_kit.App.__call__","title":"__call__  <code>async</code>","text":"<pre><code>__call__(scope: Scope, receive: Receive, send: Send)\n</code></pre> <p>ASGI call interface to delegate to the underlying Starlette app.</p>"},{"location":"api_reference/#frameio_kit.Client","title":"Client","text":"<pre><code>Client(\n    *,\n    base_url: str | None = None,\n    token: str | Callable[[], str] | None = None,\n    headers: dict[str, str] | None = None,\n    timeout: float | None = None,\n    follow_redirects: bool | None = True,\n)\n</code></pre> <p>               Bases: <code>AsyncFrameio</code></p> <p>Asynchronous HTTP client for interacting with the Frame.io v4 API.</p> <p>This class provides access to all stable API endpoints and also contains a dedicated client for experimental features via the <code>.experimental</code> property.</p> <p>Attributes:</p> <ul> <li> <code>experimental</code>               (<code>AsyncFrameioExperimental</code>)           \u2013            <p>An instance of <code>ExperimentalFrameioClient</code> for accessing endpoints that are in beta or under development.</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>close</code>             \u2013              <p>Gracefully closes the underlying <code>httpx.AsyncClient</code> session.</p> </li> </ul>"},{"location":"api_reference/#frameio_kit.Client.experimental","title":"experimental  <code>property</code>","text":"<pre><code>experimental: AsyncFrameioExperimental\n</code></pre> <p>Provides access to experimental API endpoints that are in beta or under development.</p>"},{"location":"api_reference/#frameio_kit.Client.close","title":"close  <code>async</code>","text":"<pre><code>close() -&gt; None\n</code></pre> <p>Gracefully closes the underlying <code>httpx.AsyncClient</code> session.</p>"},{"location":"api_reference/#frameio_kit.Account","title":"Account","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents the account context, used in standard webhook payloads.</p> <p>Attributes:</p> <ul> <li> <code>id</code>               (<code>str</code>)           \u2013            <p>The unique identifier (UUID) of the account.</p> </li> </ul>"},{"location":"api_reference/#frameio_kit.ActionEvent","title":"ActionEvent","text":"<p>               Bases: <code>_BaseEvent</code></p> <p>A custom action event payload, including user-submitted form data.</p> <p>This model is used for handlers registered with <code>@app.on_action</code>. It differs from <code>WebhookEvent</code> by having a top-level <code>account_id</code> and including specific fields related to the action's lifecycle.</p> <p>Attributes:</p> <ul> <li> <code>account_id</code>               (<code>str</code>)           \u2013            <p>The ID of the account where the event originated.</p> </li> <li> <code>action_id</code>               (<code>str</code>)           \u2013            <p>The ID of the custom action that was triggered.</p> </li> <li> <code>interaction_id</code>               (<code>str</code>)           \u2013            <p>A unique ID for a sequence of interactions, used to correlate steps in a multi-step custom action (e.g., a form submission).</p> </li> <li> <code>data</code>               (<code>dict[str, Any] | None</code>)           \u2013            <p>A dictionary containing submitted form data. This will be <code>None</code> for the initial trigger of an action before a form is displayed. When a form is submitted, the keys of this dictionary will match the <code>name</code> of each form field.</p> </li> </ul>"},{"location":"api_reference/#frameio_kit.ActionEvent.resource_id","title":"resource_id  <code>property</code>","text":"<pre><code>resource_id: str\n</code></pre> <p>A convenience property to directly access the resource's ID.</p> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>The unique identifier (UUID) of the event's primary resource.</p> </li> </ul>"},{"location":"api_reference/#frameio_kit.ActionEvent.user_id","title":"user_id  <code>property</code>","text":"<pre><code>user_id: str\n</code></pre> <p>A convenience property to directly access the user's ID.</p> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>The unique identifier (UUID) of the user.</p> </li> </ul>"},{"location":"api_reference/#frameio_kit.ActionEvent.project_id","title":"project_id  <code>property</code>","text":"<pre><code>project_id: str\n</code></pre> <p>A convenience property to directly access the project's ID.</p> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>The unique identifier (UUID) of the project.</p> </li> </ul>"},{"location":"api_reference/#frameio_kit.ActionEvent.workspace_id","title":"workspace_id  <code>property</code>","text":"<pre><code>workspace_id: str\n</code></pre> <p>A convenience property to directly access the workspace's ID.</p> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>The unique identifier (UUID) of the workspace.</p> </li> </ul>"},{"location":"api_reference/#frameio_kit.ActionEvent.account","title":"account  <code>property</code>","text":"<pre><code>account: Account\n</code></pre> <p>A convenience property to access the account as an Account object.</p> <p>This provides consistency with WebhookEvent, allowing access to the account ID via <code>event.account.id</code> for both event types.</p> <p>Returns:</p> <ul> <li> <code>Account</code>           \u2013            <p>An Account object containing the account ID.</p> </li> </ul>"},{"location":"api_reference/#frameio_kit.Project","title":"Project","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents the project context in which an event occurred.</p> <p>Attributes:</p> <ul> <li> <code>id</code>               (<code>str</code>)           \u2013            <p>The unique identifier (UUID) of the project.</p> </li> </ul>"},{"location":"api_reference/#frameio_kit.Resource","title":"Resource","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents the primary resource that an event pertains to.</p> <p>Attributes:</p> <ul> <li> <code>id</code>               (<code>str</code>)           \u2013            <p>The unique identifier (UUID) of the resource.</p> </li> <li> <code>type</code>               (<code>Literal['file', 'folder', 'version_stack']</code>)           \u2013            <p>The type of the resource (e.g., 'file', 'folder').</p> </li> </ul>"},{"location":"api_reference/#frameio_kit.User","title":"User","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents the user who initiated the event.</p> <p>Attributes:</p> <ul> <li> <code>id</code>               (<code>str</code>)           \u2013            <p>The unique identifier (UUID) of the user.</p> </li> </ul>"},{"location":"api_reference/#frameio_kit.WebhookEvent","title":"WebhookEvent","text":"<p>               Bases: <code>_BaseEvent</code></p> <p>A standard webhook event payload from Frame.io.</p> <p>This model is used for handlers registered with <code>@app.on_webhook</code>.</p> <p>Attributes:</p> <ul> <li> <code>account</code>               (<code>Account</code>)           \u2013            <p>The account context object for the event.</p> </li> </ul>"},{"location":"api_reference/#frameio_kit.WebhookEvent.resource_id","title":"resource_id  <code>property</code>","text":"<pre><code>resource_id: str\n</code></pre> <p>A convenience property to directly access the resource's ID.</p> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>The unique identifier (UUID) of the event's primary resource.</p> </li> </ul>"},{"location":"api_reference/#frameio_kit.WebhookEvent.user_id","title":"user_id  <code>property</code>","text":"<pre><code>user_id: str\n</code></pre> <p>A convenience property to directly access the user's ID.</p> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>The unique identifier (UUID) of the user.</p> </li> </ul>"},{"location":"api_reference/#frameio_kit.WebhookEvent.project_id","title":"project_id  <code>property</code>","text":"<pre><code>project_id: str\n</code></pre> <p>A convenience property to directly access the project's ID.</p> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>The unique identifier (UUID) of the project.</p> </li> </ul>"},{"location":"api_reference/#frameio_kit.WebhookEvent.workspace_id","title":"workspace_id  <code>property</code>","text":"<pre><code>workspace_id: str\n</code></pre> <p>A convenience property to directly access the workspace's ID.</p> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>The unique identifier (UUID) of the workspace.</p> </li> </ul>"},{"location":"api_reference/#frameio_kit.WebhookEvent.account_id","title":"account_id  <code>property</code>","text":"<pre><code>account_id: str\n</code></pre> <p>A convenience property to directly access the account's ID.</p> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>The unique identifier (UUID) of the account.</p> </li> </ul>"},{"location":"api_reference/#frameio_kit.Workspace","title":"Workspace","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents the workspace (formerly Team) in which an event occurred.</p> <p>Attributes:</p> <ul> <li> <code>id</code>               (<code>str</code>)           \u2013            <p>The unique identifier (UUID) of the workspace.</p> </li> </ul>"},{"location":"api_reference/#frameio_kit.ConfigurationError","title":"ConfigurationError","text":"<p>               Bases: <code>FrameioKitError</code></p> <p>Raised when application configuration is invalid.</p> <p>This exception is raised during startup validation when the application configuration is incomplete or inconsistent.</p> Example <ul> <li>Action requires user auth but OAuth not configured</li> <li>No secret source available for a handler</li> </ul>"},{"location":"api_reference/#frameio_kit.EventValidationError","title":"EventValidationError","text":"<pre><code>EventValidationError(\n    event_type: str, validation_errors: str\n)\n</code></pre> <p>               Bases: <code>FrameioKitError</code></p> <p>Raised when event payload validation fails.</p> <p>This exception wraps Pydantic validation errors to provide a consistent exception type for the SDK.</p> <p>Attributes:</p> <ul> <li> <code>event_type</code>           \u2013            <p>The event type that failed validation.</p> </li> <li> <code>validation_errors</code>           \u2013            <p>Details about what fields failed validation.</p> </li> </ul>"},{"location":"api_reference/#frameio_kit.FrameioKitError","title":"FrameioKitError","text":"<p>               Bases: <code>Exception</code></p> <p>Base exception for all Frame.io Kit errors.</p> <p>All exceptions raised by this library inherit from this base class, making it easy to catch any SDK-related error.</p> Example <pre><code>try:\n    await app.validate_configuration()\nexcept FrameioKitError as e:\n    logger.error(f\"SDK error: {e}\")\n</code></pre>"},{"location":"api_reference/#frameio_kit.InstallationError","title":"InstallationError","text":"<p>               Bases: <code>FrameioKitError</code></p> <p>Base exception for installation-related errors.</p>"},{"location":"api_reference/#frameio_kit.InstallationNotFoundError","title":"InstallationNotFoundError","text":"<p>               Bases: <code>InstallationError</code></p> <p>No installation found for the given workspace.</p>"},{"location":"api_reference/#frameio_kit.OAuthError","title":"OAuthError","text":"<p>               Bases: <code>FrameioKitError</code></p> <p>Base exception for OAuth-related errors.</p>"},{"location":"api_reference/#frameio_kit.SecretResolutionError","title":"SecretResolutionError","text":"<pre><code>SecretResolutionError(\n    event_type: str, message: str | None = None\n)\n</code></pre> <p>               Bases: <code>FrameioKitError</code></p> <p>Raised when secret resolution fails.</p> <p>This exception is raised when the secret for signature verification cannot be resolved from any source (decorator, app-level resolver, or environment variable).</p> <p>Attributes:</p> <ul> <li> <code>event_type</code>           \u2013            <p>The event type for which secret resolution failed.</p> </li> <li> <code>message</code>           \u2013            <p>Descriptive error message.</p> </li> </ul>"},{"location":"api_reference/#frameio_kit.SignatureVerificationError","title":"SignatureVerificationError","text":"<p>               Bases: <code>FrameioKitError</code></p> <p>Raised when request signature verification fails.</p> <p>This exception indicates that the HMAC signature in the request headers does not match the expected signature, suggesting the request may have been tampered with or did not originate from Frame.io.</p>"},{"location":"api_reference/#frameio_kit.TokenExchangeError","title":"TokenExchangeError","text":"<p>               Bases: <code>OAuthError</code></p> <p>Raised when OAuth token exchange fails.</p> <p>This can occur when: - The authorization code is invalid or expired - Required fields are missing from the token response - The token response contains invalid data</p>"},{"location":"api_reference/#frameio_kit.TokenRefreshError","title":"TokenRefreshError","text":"<p>               Bases: <code>OAuthError</code></p> <p>Raised when OAuth token refresh fails.</p> <p>This typically indicates the refresh token has been revoked or expired, requiring the user to re-authenticate.</p>"},{"location":"api_reference/#frameio_kit.Middleware","title":"Middleware","text":"<p>Base class for creating middleware in Frame.io integrations.</p> <p>Middleware provides a powerful way to add cross-cutting concerns to your Frame.io integration without cluttering your handler functions. You can use middleware for logging, authentication, metrics collection, error handling, and more.</p> <p>The <code>Middleware</code> base class provides three hooks you can override:</p> <ul> <li><code>__call__</code>: The main entry point that runs for every event (both webhooks and actions)</li> <li><code>on_webhook</code>: Runs only for webhook events</li> <li><code>on_action</code>: Runs only for custom action events</li> </ul> Example <pre><code>class TimingMiddleware(Middleware):\n    async def __call__(self, event: AnyEvent, next: NextFunc) -&gt; AnyResponse:\n        start_time = time.monotonic()\n        response = await next(event)\n        duration = time.monotonic() - start_time\n        print(f\"Processed {event.type} in {duration:.2f}s\")\n        return response\n\napp = App(middleware=[TimingMiddleware()])\n</code></pre> <p>Methods:</p> <ul> <li> <code>__call__</code>             \u2013              <p>The main entry point that runs for every event (both webhooks and actions).</p> </li> <li> <code>on_webhook</code>             \u2013              <p>Runs only for webhook events.</p> </li> <li> <code>on_action</code>             \u2013              <p>Runs only for custom action events.</p> </li> </ul>"},{"location":"api_reference/#frameio_kit.Middleware.__call__","title":"__call__  <code>async</code>","text":"<pre><code>__call__(event: AnyEvent, next: NextFunc) -&gt; AnyResponse\n</code></pre> <p>The main entry point that runs for every event (both webhooks and actions). This is where you implement logic that should apply universally.</p> <p>Override this method when you need logic that should run on every single event, regardless of its type. This is perfect for universal concerns like:</p> <ul> <li>Request timing and performance monitoring</li> <li>Error handling and logging</li> <li>Authentication and authorization</li> <li>Request/response transformation</li> </ul> <p>Parameters:</p> <ul> <li> </li> <li> </li> </ul> <p>Returns:</p> <ul> <li> <code>AnyResponse</code>           \u2013            <p>The response from the next middleware or handler, or None</p> </li> </ul> Example <pre><code>async def __call__(self, event: AnyEvent, next: NextFunc) -&gt; AnyResponse:\n    # Code here runs before every event\n    result = await next(event)  # Call the next middleware or handler\n    # Code here runs after every event\n    return result\n</code></pre> Note <p>When you override <code>__call__</code>, you completely replace the base implementation. This means: - Without <code>super()</code>: The <code>on_webhook</code> and <code>on_action</code> methods will not be called - With <code>super()</code>: The original dispatch logic is preserved, so <code>on_webhook</code> and <code>on_action</code> will still be called</p>"},{"location":"api_reference/#frameio_kit.Middleware.__call__(event)","title":"<code>event</code>","text":"(<code>AnyEvent</code>)           \u2013            <p>The event being processed (WebhookEvent or ActionEvent)</p>"},{"location":"api_reference/#frameio_kit.Middleware.__call__(next)","title":"<code>next</code>","text":"(<code>NextFunc</code>)           \u2013            <p>Function to call the next middleware or handler in the chain</p>"},{"location":"api_reference/#frameio_kit.Middleware.on_webhook","title":"on_webhook  <code>async</code>","text":"<pre><code>on_webhook(\n    event: WebhookEvent, next: NextFunc\n) -&gt; AnyResponse\n</code></pre> <p>Runs only for webhook events.</p> <p>Override this method when you need webhook-specific logic that doesn't apply to custom actions.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>AnyResponse</code>           \u2013            <p>The response from the next middleware or handler, or None</p> </li> </ul> Example <pre><code>async def on_webhook(self, event: WebhookEvent, next: NextFunc) -&gt; AnyResponse:\n    # Code here runs only for webhook events\n    result = await next(event)\n    return result\n</code></pre>"},{"location":"api_reference/#frameio_kit.Middleware.on_webhook(event)","title":"<code>event</code>","text":"(<code>WebhookEvent</code>)           \u2013            <p>The webhook event being processed</p>"},{"location":"api_reference/#frameio_kit.Middleware.on_webhook(next)","title":"<code>next</code>","text":"(<code>NextFunc</code>)           \u2013            <p>Function to call the next middleware or handler in the chain</p>"},{"location":"api_reference/#frameio_kit.Middleware.on_action","title":"on_action  <code>async</code>","text":"<pre><code>on_action(\n    event: ActionEvent, next: NextFunc\n) -&gt; AnyResponse\n</code></pre> <p>Runs only for custom action events.</p> <p>Override this method when you need action-specific logic that doesn't apply to webhooks.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>AnyResponse</code>           \u2013            <p>The response from the next middleware or handler, or None</p> </li> </ul> Example <pre><code>async def on_action(self, event: ActionEvent, next: NextFunc) -&gt; AnyResponse:\n    # Code here runs only for action events\n    result = await next(event)\n    return result\n</code></pre>"},{"location":"api_reference/#frameio_kit.Middleware.on_action(event)","title":"<code>event</code>","text":"(<code>ActionEvent</code>)           \u2013            <p>The action event being processed</p>"},{"location":"api_reference/#frameio_kit.Middleware.on_action(next)","title":"<code>next</code>","text":"(<code>NextFunc</code>)           \u2013            <p>Function to call the next middleware or handler in the chain</p>"},{"location":"api_reference/#frameio_kit.OAuthConfig","title":"OAuthConfig","text":"<p>               Bases: <code>BaseModel</code></p> <p>OAuth configuration for Adobe IMS authentication.</p> <p>This configuration is provided at the application level to enable user authentication via Adobe Login OAuth 2.0 flow. Contains only OAuth-specific credentials and settings. Storage and encryption are configured at the <code>App</code> level.</p> <p>Attributes:</p> <ul> <li> <code>client_id</code>               (<code>str</code>)           \u2013            <p>Adobe IMS application client ID from Adobe Developer Console.</p> </li> <li> <code>client_secret</code>               (<code>str</code>)           \u2013            <p>Adobe IMS application client secret.</p> </li> <li> <code>redirect_url</code>               (<code>str | None</code>)           \u2013            <p>Full OAuth callback URL (e.g., \"https://myapp.com/auth/callback\"). If None, the URL will be automatically inferred from incoming requests. Set this explicitly when behind a reverse proxy or when the public URL differs from what the application sees. Must be registered in Adobe Console.</p> </li> <li> <code>scopes</code>               (<code>list[str]</code>)           \u2013            <p>List of OAuth scopes to request. Defaults to Frame.io API access.</p> </li> <li> <code>token_refresh_buffer_seconds</code>               (<code>int</code>)           \u2013            <p>Number of seconds before token expiration to trigger automatic refresh. Defaults to 300 seconds (5 minutes). This prevents token expiration during ongoing API calls.</p> </li> <li> <code>http_client</code>               (<code>Optional[AsyncClient]</code>)           \u2013            <p>Optional httpx.AsyncClient for OAuth HTTP requests. If not provided, a new client will be created. Providing your own enables connection pooling, custom timeouts, and shared configuration.</p> </li> </ul> Example <pre><code>from frameio_kit import App, OAuthConfig\n\napp = App(\n    oauth=OAuthConfig(\n        client_id=os.getenv(\"ADOBE_CLIENT_ID\"),\n        client_secret=os.getenv(\"ADOBE_CLIENT_SECRET\"),\n    ),\n)\n</code></pre>"},{"location":"api_reference/#frameio_kit.MemoryStorage","title":"MemoryStorage","text":"<pre><code>MemoryStorage()\n</code></pre> <p>In-memory storage backend for development and testing.</p> <p>Values are stored in a dictionary with optional TTL support using monotonic time. Expired entries are lazily cleaned up on access.</p> Example <pre><code>storage = MemoryStorage()\nawait storage.put(\"key\", {\"data\": \"value\"}, ttl=3600)\nresult = await storage.get(\"key\")\n</code></pre>"},{"location":"api_reference/#frameio_kit.Storage","title":"Storage","text":"<p>               Bases: <code>Protocol</code></p> <p>Protocol for async key-value storage backends.</p> <p>Implementations must support get, put, and delete operations with optional TTL (time-to-live) support for automatic expiration.</p> Example <pre><code>class MyStorage:\n    async def get(self, key: str) -&gt; dict[str, Any] | None:\n        ...\n\n    async def put(self, key: str, value: dict[str, Any], *, ttl: int | None = None) -&gt; None:\n        ...\n\n    async def delete(self, key: str) -&gt; None:\n        ...\n</code></pre> <p>Methods:</p> <ul> <li> <code>get</code>             \u2013              <p>Retrieve a value by key.</p> </li> <li> <code>put</code>             \u2013              <p>Store a value with an optional TTL.</p> </li> <li> <code>delete</code>             \u2013              <p>Delete a value by key.</p> </li> </ul>"},{"location":"api_reference/#frameio_kit.Storage.get","title":"get  <code>async</code>","text":"<pre><code>get(key: str) -&gt; dict[str, Any] | None\n</code></pre> <p>Retrieve a value by key.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>dict[str, Any] | None</code>           \u2013            <p>The stored dictionary, or None if the key does not exist or has expired.</p> </li> </ul>"},{"location":"api_reference/#frameio_kit.Storage.get(key)","title":"<code>key</code>","text":"(<code>str</code>)           \u2013            <p>The storage key.</p>"},{"location":"api_reference/#frameio_kit.Storage.put","title":"put  <code>async</code>","text":"<pre><code>put(\n    key: str,\n    value: dict[str, Any],\n    *,\n    ttl: int | None = None,\n) -&gt; None\n</code></pre> <p>Store a value with an optional TTL.</p> <p>Parameters:</p>"},{"location":"api_reference/#frameio_kit.Storage.put(key)","title":"<code>key</code>","text":"(<code>str</code>)           \u2013            <p>The storage key.</p>"},{"location":"api_reference/#frameio_kit.Storage.put(value)","title":"<code>value</code>","text":"(<code>dict[str, Any]</code>)           \u2013            <p>The dictionary value to store.</p>"},{"location":"api_reference/#frameio_kit.Storage.put(ttl)","title":"<code>ttl</code>","text":"(<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>Optional time-to-live in seconds. If None, the value does not expire.</p>"},{"location":"api_reference/#frameio_kit.Storage.delete","title":"delete  <code>async</code>","text":"<pre><code>delete(key: str) -&gt; None\n</code></pre> <p>Delete a value by key.</p> <p>Parameters:</p>"},{"location":"api_reference/#frameio_kit.Storage.delete(key)","title":"<code>key</code>","text":"(<code>str</code>)           \u2013            <p>The storage key. No error is raised if the key does not exist.</p>"},{"location":"api_reference/#frameio_kit.DynamoDBStorage","title":"DynamoDBStorage","text":"<pre><code>DynamoDBStorage(\n    table_name: str,\n    region_name: str | None = None,\n    endpoint_url: str | None = None,\n    boto_session_kwargs: dict[str, Any] | None = None,\n)\n</code></pre> <p>DynamoDB storage backend for multi-server deployments.</p> <p>Uses aioboto3 (optional dependency) to interact with DynamoDB. Each call creates a short-lived resource context manager to avoid holding connections open between requests.</p> <p>Client-side TTL checking is performed on <code>get()</code> because DynamoDB's built-in TTL cleanup is eventually consistent and may leave expired items readable for up to 48 hours.</p> Example <pre><code>from frameio_kit._storage_dynamodb import DynamoDBStorage\n\n# Uses boto3 default region resolution\nstorage = DynamoDBStorage(table_name=\"frameio-oauth-tokens\")\n\n# Or specify a region explicitly\nstorage = DynamoDBStorage(table_name=\"frameio-oauth-tokens\", region_name=\"us-east-1\")\n</code></pre> <p>Parameters:</p>"},{"location":"api_reference/#frameio_kit.DynamoDBStorage(table_name)","title":"<code>table_name</code>","text":"(<code>str</code>)           \u2013            <p>Name of the DynamoDB table.</p>"},{"location":"api_reference/#frameio_kit.DynamoDBStorage(region_name)","title":"<code>region_name</code>","text":"(<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>AWS region (e.g. <code>\"us-east-1\"</code>). Defaults to the boto3 default region from environment variables, AWS config files, or instance metadata.</p>"},{"location":"api_reference/#frameio_kit.DynamoDBStorage(endpoint_url)","title":"<code>endpoint_url</code>","text":"(<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Optional endpoint URL (useful for local DynamoDB).</p>"},{"location":"api_reference/#frameio_kit.DynamoDBStorage(boto_session_kwargs)","title":"<code>boto_session_kwargs</code>","text":"(<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Optional extra kwargs passed to <code>aioboto3.Session()</code>.</p>"},{"location":"api_reference/#frameio_kit.CheckboxField","title":"CheckboxField","text":"<p>               Bases: <code>_BaseField</code></p> <p>A checkbox input.</p> <p>Example:</p> <pre><code>from frameio_kit import Form, CheckboxField\n\nreturn Form(\n    title=\"Confirm Action\",\n    fields=[CheckboxField(label=\"Overwrite existing file?\", name=\"overwrite\", value=False)]\n)\n</code></pre> <p>Attributes:</p> <ul> <li> <code>type</code>               (<code>Literal['checkbox']</code>)           \u2013            <p>The field type, fixed to \"checkbox\".</p> </li> <li> <code>value</code>               (<code>bool | None</code>)           \u2013            <p>An optional default state for the checkbox (<code>True</code> for checked).</p> </li> </ul>"},{"location":"api_reference/#frameio_kit.Form","title":"Form","text":"<p>               Bases: <code>_UIResponse</code></p> <p>A modal with a form to collect input from the user.</p> <p>When returned from a handler, this model renders a form in the Frame.io UI. Upon submission, Frame.io sends another <code>ActionEvent</code> to your endpoint, this time populating the <code>data</code> attribute with the user's input.</p> <p>Attributes:</p> <ul> <li> <code>fields</code>               (<code>list[FormField]</code>)           \u2013            <p>A list of one or more form field objects (e.g., <code>TextField</code>, <code>SelectField</code>) to be displayed in the form.</p> </li> </ul>"},{"location":"api_reference/#frameio_kit.LinkField","title":"LinkField","text":"<p>               Bases: <code>_BaseField</code></p> <p>A non-editable field that displays a URL with a \"Copy\" button.</p> <p>This is useful for presenting a user with a link to an external resource that was generated as part of the action.</p> <p>Example:</p> <pre><code>from frameio_kit import Form, LinkField\n\nreturn Form(\n    title=\"External Link\",\n    fields=[LinkField(label=\"External Link\", name=\"external_link\", value=\"https://www.example.com\")]\n)\n</code></pre> <p>Attributes:</p> <ul> <li> <code>type</code>               (<code>Literal['link']</code>)           \u2013            <p>The field type, fixed to \"link\".</p> </li> <li> <code>value</code>               (<code>str | None</code>)           \u2013            <p>The URL to be displayed.</p> </li> </ul>"},{"location":"api_reference/#frameio_kit.Message","title":"Message","text":"<p>               Bases: <code>_UIResponse</code></p> <p>A simple message modal to display information to the user.</p> <p>This is typically used as the final step in a custom action to confirm that an operation was successful or to provide information.</p> <p>Example:</p> <pre><code>from frameio_kit import Message\n\nreturn Message(title=\"Success\", description=\"The action was successful.\")\n</code></pre>"},{"location":"api_reference/#frameio_kit.SelectField","title":"SelectField","text":"<p>               Bases: <code>_BaseField</code></p> <p>A dropdown menu allowing the user to select one from a list of options.</p> <p>Example:</p> <pre><code>from frameio_kit import Form, SelectField, SelectOption\n\nPLATFORMS = [\n    SelectOption(name=\"Twitter\", value=\"twitter\"),\n    SelectOption(name=\"Instagram\", value=\"instagram\"),\n]\n\nreturn Form(\n    title=\"Choose Platform\",\n    fields=[SelectField(label=\"Platform\", name=\"platform\", options=PLATFORMS)]\n)\n</code></pre> <p>Attributes:</p> <ul> <li> <code>type</code>               (<code>Literal['select']</code>)           \u2013            <p>The field type, fixed to \"select\".</p> </li> <li> <code>options</code>               (<code>list[SelectOption]</code>)           \u2013            <p>A list of <code>SelectOption</code> objects defining the choices.</p> </li> <li> <code>value</code>               (<code>str | None</code>)           \u2013            <p>An optional default value to pre-select an option. This must match the <code>value</code> of one of the items in the <code>options</code> list.</p> </li> </ul>"},{"location":"api_reference/#frameio_kit.SelectOption","title":"SelectOption","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents a single choice within a <code>SelectField</code>.</p> <p>Attributes:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The user-visible text for the option in the dropdown list.</p> </li> <li> <code>value</code>               (<code>str</code>)           \u2013            <p>The actual value that will be sent back in the <code>data</code> payload if this option is selected.</p> </li> </ul>"},{"location":"api_reference/#frameio_kit.TextareaField","title":"TextareaField","text":"<p>               Bases: <code>_BaseField</code></p> <p>A multi-line text input area, suitable for longer descriptions.</p> <p>Example:</p> <pre><code>from frameio_kit import Form, TextareaField\n\nreturn Form(\n    title=\"Comment\",\n    fields=[TextareaField(label=\"Comment\", name=\"comment\", value=\"Enter your feedback...\")]\n)\n</code></pre> <p>Attributes:</p> <ul> <li> <code>type</code>               (<code>Literal['textarea']</code>)           \u2013            <p>The field type, fixed to \"textarea\".</p> </li> <li> <code>value</code>               (<code>str | None</code>)           \u2013            <p>An optional default value to pre-populate the field.</p> </li> </ul>"},{"location":"api_reference/#frameio_kit.TextField","title":"TextField","text":"<p>               Bases: <code>_BaseField</code></p> <p>A single-line text input field.</p> <p>Example:</p> <pre><code>from frameio_kit import Form, TextField\n\nreturn Form(\n    title=\"Comment\",\n    fields=[TextField(label=\"Comment\", name=\"comment\", value=\"Enter your feedback...\")]\n)\n</code></pre> <p>Attributes:</p> <ul> <li> <code>type</code>               (<code>Literal['text']</code>)           \u2013            <p>The field type, fixed to \"text\".</p> </li> <li> <code>value</code>               (<code>str | None</code>)           \u2013            <p>An optional default value to pre-populate the field.</p> </li> </ul>"},{"location":"api_reference/#frameio_kit.ActionRecord","title":"ActionRecord","text":"<p>               Bases: <code>BaseModel</code></p> <p>Record of a custom action created during installation.</p> <p>Attributes:</p> <ul> <li> <code>action_id</code>               (<code>str</code>)           \u2013            <p>Frame.io custom action ID.</p> </li> <li> <code>secret</code>               (<code>str</code>)           \u2013            <p>Encrypted signing secret returned at creation time.</p> </li> <li> <code>event_type</code>               (<code>str</code>)           \u2013            <p>The event type string for this action.</p> </li> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>Display name of the action.</p> </li> <li> <code>description</code>               (<code>str</code>)           \u2013            <p>Description of the action.</p> </li> <li> <code>url</code>               (<code>str</code>)           \u2013            <p>Callback URL the action posts to.</p> </li> </ul>"},{"location":"api_reference/#frameio_kit.Installation","title":"Installation","text":"<p>               Bases: <code>BaseModel</code></p> <p>Record of a complete app installation for a workspace.</p> <p>Attributes:</p> <ul> <li> <code>account_id</code>               (<code>str</code>)           \u2013            <p>Frame.io account ID.</p> </li> <li> <code>workspace_id</code>               (<code>str</code>)           \u2013            <p>Frame.io workspace ID.</p> </li> <li> <code>installed_at</code>               (<code>datetime</code>)           \u2013            <p>When the installation was first created.</p> </li> <li> <code>updated_at</code>               (<code>datetime</code>)           \u2013            <p>When the installation was last updated.</p> </li> <li> <code>webhook</code>               (<code>WebhookRecord | None</code>)           \u2013            <p>The consolidated webhook record, if any webhook handlers exist.</p> </li> <li> <code>actions</code>               (<code>list[ActionRecord]</code>)           \u2013            <p>List of custom action records, one per action handler.</p> </li> </ul>"},{"location":"api_reference/#frameio_kit.WebhookRecord","title":"WebhookRecord","text":"<p>               Bases: <code>BaseModel</code></p> <p>Record of a webhook created during installation.</p> <p>Attributes:</p> <ul> <li> <code>webhook_id</code>               (<code>str</code>)           \u2013            <p>Frame.io webhook ID.</p> </li> <li> <code>secret</code>               (<code>str</code>)           \u2013            <p>Encrypted signing secret returned at creation time.</p> </li> <li> <code>events</code>               (<code>list[str]</code>)           \u2013            <p>List of event types the webhook listens for.</p> </li> <li> <code>url</code>               (<code>str</code>)           \u2013            <p>Callback URL the webhook posts to.</p> </li> </ul>"},{"location":"api_reference/#frameio_kit.get_user_token","title":"get_user_token","text":"<pre><code>get_user_token() -&gt; str\n</code></pre> <p>Get the authenticated user's access token.</p> <p>This function retrieves the OAuth access token for the currently authenticated user. It can only be called within an action handler that has user authentication enabled (require_user_auth=True).</p> <p>The token is stored in request-scoped context, not on the event object, to prevent accidental logging or exposure of sensitive credentials.</p> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>The user's OAuth access token string.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>RuntimeError</code>             \u2013            <p>If called outside a user-authenticated action context.</p> </li> </ul> Example <pre><code>from frameio_kit import App, get_user_token, Client\n\n@app.on_action(..., require_user_auth=True)\nasync def process_file(event: ActionEvent):\n    # Get the user's token\n    token = get_user_token()\n\n    # Use it with the built-in Client\n    async with Client(token=token) as user_client:\n        ...\n\n    # Or pass to other services\n    await external_service.authenticate(token)\n</code></pre>"},{"location":"api_reference/#frameio_kit.verify_signature","title":"verify_signature  <code>async</code>","text":"<pre><code>verify_signature(\n    headers: Headers, body: bytes, secret: str\n) -&gt; bool\n</code></pre> <p>Verifies the HMAC-SHA256 signature of an incoming Frame.io request.</p> <p>This function is a critical security utility for validating that a webhook or custom action request genuinely originated from Frame.io and that its payload has not been tampered with. It should be called at the beginning of any request handler that receives events from Frame.io.</p> <p>It validates the request by checking the timestamp to prevent replay attacks and by computing an HMAC-SHA256 signature from the request body and your unique secret, comparing it securely to the signature provided in the header.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True if the signature is valid and the request is authentic.</p> </li> <li> <code>bool</code>           \u2013            <p>False if the signature is invalid, the timestamp is too old, or</p> </li> <li> <code>bool</code>           \u2013            <p>required headers are missing.</p> </li> </ul>"},{"location":"api_reference/#frameio_kit.verify_signature(headers)","title":"<code>headers</code>","text":"(<code>Headers</code>)           \u2013            <p>The incoming request headers, obtained directly from your web framework's request object (e.g., <code>request.headers</code>). This function expects to find 'X-Frameio-Request-Timestamp' and 'X-Frameio-Signature' headers.</p>"},{"location":"api_reference/#frameio_kit.verify_signature(body)","title":"<code>body</code>","text":"(<code>bytes</code>)           \u2013            <p>The raw, unmodified request body as bytes, obtained directly from your web framework's request object (e.g., <code>await request.body()</code>). It is crucial that this is the raw body, not a parsed JSON object.</p>"},{"location":"api_reference/#frameio_kit.verify_signature(secret)","title":"<code>secret</code>","text":"(<code>str</code>)           \u2013            <p>The unique signing secret provided by Frame.io when you created the webhook or custom action. It's recommended to store this securely (e.g., as an environment variable).</p>"},{"location":"usage/app/","title":"App Configuration","text":"<p>The <code>App</code> class is the central entry point for your Frame.io integration. This guide covers app-level configuration options.</p>"},{"location":"usage/app/#basic-initialization","title":"Basic Initialization","text":"<pre><code>from frameio_kit import App\n\napp = App()\n</code></pre> <p>Mounting to Existing Applications</p> <p>If you have an existing ASGI application (FastAPI, Starlette, etc.), you can mount your frameio-kit <code>App</code> directly to it without any code changes. See Mounting to Existing Apps for details.</p>"},{"location":"usage/app/#configuration-options","title":"Configuration Options","text":""},{"location":"usage/app/#api-token","title":"API Token","text":"<p>Provide an API token to enable authenticated calls to the Frame.io API via <code>app.client</code>:</p> <pre><code>import os\n\napp = App(token=os.getenv(\"FRAMEIO_TOKEN\"))\n\n# Use the client in handlers\n@app.on_webhook(\"file.ready\")\nasync def on_file_ready(event: WebhookEvent):\n    file = await app.client.files.show(\n        account_id=event.account_id,\n        file_id=event.resource_id\n    )\n    print(f\"File name: {file.data.name}\")\n</code></pre> <p>See Client API for more details.</p>"},{"location":"usage/app/#middleware","title":"Middleware","text":"<p>Add middleware for logging, metrics, error handling, and more:</p> <pre><code>from frameio_kit import App, Middleware\n\nclass LoggingMiddleware(Middleware):\n    async def __call__(self, event, next):\n        print(f\"Processing event: {event.type}\")\n        response = await next(event)\n        print(f\"Event processed: {event.type}\")\n        return response\n\napp = App(middleware=[LoggingMiddleware()])\n</code></pre> <p>See Middleware for detailed examples.</p>"},{"location":"usage/app/#oauth-configuration","title":"OAuth Configuration","text":"<p>Enable Adobe Login OAuth for user authentication:</p> <pre><code>from frameio_kit import App, OAuthConfig\n\napp = App(\n    oauth=OAuthConfig(\n        client_id=os.getenv(\"OAUTH_CLIENT_ID\"),\n        client_secret=os.getenv(\"OAUTH_CLIENT_SECRET\"),\n        redirect_url=\"https://your-app.com/auth/callback\",\n    ),\n    encryption_key=os.getenv(\"ENCRYPTION_KEY\"),\n)\n</code></pre> <p>See User Authentication for complete OAuth setup.</p>"},{"location":"usage/app/#storage-and-encryption","title":"Storage and Encryption","text":"<p>Storage and encryption are configured at the <code>App</code> level and shared between OAuth token management and the installation system:</p> <pre><code>from frameio_kit import App, OAuthConfig, DynamoDBStorage\n\napp = App(\n    oauth=OAuthConfig(\n        client_id=os.getenv(\"OAUTH_CLIENT_ID\"),\n        client_secret=os.getenv(\"OAUTH_CLIENT_SECRET\"),\n    ),\n    storage=DynamoDBStorage(table_name=\"frameio-app-data\"),\n    encryption_key=os.getenv(\"FRAMEIO_AUTH_ENCRYPTION_KEY\"),\n)\n</code></pre> <p>See User Authentication - Storage Backends for details.</p>"},{"location":"usage/app/#branding","title":"Branding","text":"<p>Customize the install and auth callback pages with your brand identity:</p> <pre><code>app = App(\n    oauth=OAuthConfig(...),\n    install=True,\n    name=\"My Video Tool\",\n    description=\"AI-powered video analysis for your team.\",\n    logo_url=\"https://myapp.com/logo.png\",\n    primary_color=\"#1a73e8\",\n    accent_color=\"#34a853\",\n    show_powered_by=False,\n)\n</code></pre> <p>See Installation System - Branding for details.</p>"},{"location":"usage/app/#secret-resolution-precedence","title":"Secret Resolution Precedence","text":"<p>The framework follows this precedence order (highest to lowest):</p> <ol> <li>Explicit string secret at decorator (<code>secret=\"...\"</code>)</li> <li>Decorator-level resolver function (<code>secret=my_resolver</code>)</li> <li>Install system resolver (when <code>install=True</code>, secrets are auto-managed)</li> <li>Environment variables (<code>WEBHOOK_SECRET</code> / <code>CUSTOM_ACTION_SECRET</code>)</li> </ol> <p>This allows you to:</p> <ul> <li>Use the install system for automatic secret management</li> <li>Override with decorator-level resolver for specific handlers</li> <li>Override with static secrets for testing or special cases</li> </ul>"},{"location":"usage/app/#best-practices","title":"Best Practices","text":"<ol> <li>Keep secrets secure - Never log or expose secrets in error messages</li> <li>Cache when possible - If secrets don't change often, consider caching</li> <li>Handle errors gracefully - Provide clear error messages when secret lookup fails</li> <li>Test secret resolution - Ensure resolvers work correctly before deploying</li> <li>Monitor resolver performance - Secret lookup happens on every request</li> </ol>"},{"location":"usage/app/#see-also","title":"See Also","text":"<ul> <li>Mounting to Existing Apps - Mount your App to FastAPI, Starlette, or any ASGI framework</li> <li>Webhooks - Webhook-specific secret resolution</li> <li>Custom Actions - Action-specific secret resolution</li> </ul>"},{"location":"usage/client_api/","title":"Client API","text":"<p>The Frame.io API client allows you to make authenticated calls back to the Frame.io API from within your handlers. This enables you to fetch data, create resources, and interact with Frame.io programmatically.</p>"},{"location":"usage/client_api/#why-use-the-api-client","title":"Why Use the API Client?","text":"<p>The API client is essential when you need to:</p> <ul> <li>Fetch additional data about files, projects, or users</li> <li>Create resources like comments, annotations, or tasks</li> <li>Update existing data in Frame.io</li> <li>Integrate with Frame.io's full feature set beyond webhooks and actions</li> <li>Build comprehensive workflows that interact with Frame.io data</li> </ul>"},{"location":"usage/client_api/#how-the-api-client-works","title":"How the API Client Works","text":"<ol> <li>Initialize with token - Provide a Frame.io API token when creating your <code>App</code></li> <li>Access via <code>app.client</code> - The client is available as a property on your app instance</li> <li>Make async calls - All API methods are asynchronous and must be awaited</li> <li>Handle responses - API calls return structured data that you can process</li> </ol> <pre><code>Your Handler \u2192 app.client \u2192 Frame.io API \u2192 Response Data\n</code></pre>"},{"location":"usage/client_api/#initialization","title":"Initialization","text":"<p>Initialize the client by providing a Frame.io API token:</p> <pre><code>import os\nfrom frameio_kit import App\n\n# Initialize with API token\napp = App(token=os.getenv(\"FRAMEIO_TOKEN\"))\n\n# Client is now available at app.client\n</code></pre>"},{"location":"usage/client_api/#getting-an-api-token","title":"Getting an API Token","text":"<p>Follow the Server to Server Authentication guide to get an access token.</p>"},{"location":"usage/client_api/#api-structure","title":"API Structure","text":"<p>See the python examples in Frame.io's API Reference for the available endpoints.</p>"},{"location":"usage/client_api/#example-file-processing-with-comments","title":"Example: File Processing with Comments","text":"<pre><code>import os\nfrom frameio_kit import App, WebhookEvent, Message\nfrom frameio import CreateCommentParamsData\n\napp = App(token=os.getenv(\"FRAMEIO_TOKEN\"))\n\n@app.on_webhook(\"file.ready\", secret=os.environ[\"WEBHOOK_SECRET\"])\nasync def process_file(event: WebhookEvent):\n    # Get file details\n    file = await app.client.files.show(\n        account_id=event.account_id,\n        file_id=event.resource_id\n    )\n    print(f\"Processing: {file.data.name}\")\n\n    # Simulate processing\n    await process_file_content(file)\n\n    # Add a comment to the file\n    await app.client.comments.create(\n        account_id=event.account_id,\n        file_id=event.resource_id,\n        data=CreateCommentParamsData(text=\"\u2705 File processed successfully!\")\n    )\n\nasync def process_file_content(file):\n    # Your processing logic here\n    pass\n</code></pre>"},{"location":"usage/client_api/#best-practices","title":"Best Practices","text":"<ol> <li>Always use <code>await</code> - All API calls are asynchronous</li> <li>Handle errors gracefully - API calls can fail for various reasons</li> <li>Use appropriate permissions - Ensure your token has the required scopes</li> <li>Cache when possible - Avoid repeated calls for the same data</li> <li>Respect rate limits - Frame.io has API rate limits</li> <li>Use environment variables for tokens and sensitive data</li> </ol>"},{"location":"usage/client_api/#experimental-api","title":"Experimental API","text":"<p>Access experimental features via <code>app.client.experimental</code>:</p> <pre><code># Experimental custom actions API\nactions = await app.client.experimental.custom_actions.actions_index(\n    account_id=event.account_id,\n    workspace_id=event.workspace_id,\n)\n</code></pre> <p>Note: Experimental APIs may change without notice. Use with caution in production.</p>"},{"location":"usage/client_api/#authentication","title":"Authentication","text":""},{"location":"usage/client_api/#server-to-server-authentication-default","title":"Server-to-Server Authentication (Default)","text":"<p>The client automatically handles authentication using your provided token. No additional setup is required - just make sure your token has the necessary permissions for the operations you want to perform.</p> <pre><code>app = App(token=os.getenv(\"FRAMEIO_TOKEN\"))\n\n# Use app.client for S2S authenticated calls\nfile = await app.client.files.show(...)\n</code></pre>"},{"location":"usage/client_api/#user-authentication","title":"User Authentication","text":"<p>For user-specific authentication, you can create a client with a user's OAuth token. This attributes API calls to the user in Frame.io activity logs.</p> <pre><code>from frameio_kit import Client, get_user_token\n\n@app.on_action(..., require_user_auth=True)\nasync def my_action(event: ActionEvent):\n    # Create client with user's token from context\n    async with Client(token=get_user_token()) as user_client:\n        # API calls are now attributed to the user\n        file = await user_client.files.show(...)\n</code></pre> <p>See the User Authentication guide for details on enabling Adobe Login OAuth.</p>"},{"location":"usage/custom_actions/","title":"Custom Actions","text":"<p>Custom Actions are user-triggered menu items in the Frame.io UI. They're perfect for building interactive workflows that can present information, ask for user input, and perform tasks on demand.</p>"},{"location":"usage/custom_actions/#why-use-custom-actions","title":"Why Use Custom Actions?","text":"<p>Custom Actions are ideal when you need to:</p> <ul> <li>Build interactive workflows that require user input</li> <li>Create on-demand tools for specific tasks</li> <li>Integrate external services with Frame.io assets</li> <li>Automate complex processes with user guidance</li> <li>Provide contextual actions based on the selected asset</li> </ul>"},{"location":"usage/custom_actions/#how-custom-actions-work","title":"How Custom Actions Work","text":"<ol> <li>User clicks action in the Frame.io UI (right-click menu, toolbar, etc.)</li> <li>Your handler is called with the action event</li> <li>Return a response - either a <code>Message</code> for simple feedback or a <code>Form</code> for user input</li> <li>If Form returned - user fills it out and submits, your handler is called again with the form data</li> </ol> <pre><code>User Click \u2192 Handler \u2192 Message (done) OR Form \u2192 User Input \u2192 Handler \u2192 Message\n</code></pre>"},{"location":"usage/custom_actions/#action-decorator","title":"Action Decorator","text":"<p>Use the <code>@app.on_action</code> decorator to register handlers:</p> <pre><code>import os\n\n# Single action - use default CUSTOM_ACTION_SECRET env var\n@app.on_action(\n    event_type=\"my_app.analyze\",\n    name=\"Analyze File\",\n    description=\"Perform analysis on this file\"\n)\nasync def analyze_file(event: ActionEvent):\n    # Handle the action\n    pass\n\n# Multiple actions with different secrets - use explicit env vars\n@app.on_action(\n    event_type=\"my_app.analyze\",\n    name=\"Analyze File\",\n    description=\"Perform analysis on this file\",\n    secret=os.environ[\"ANALYZE_CUSTOM_ACTION_SECRET\"]\n)\nasync def analyze_file(event: ActionEvent):\n    pass\n\n@app.on_action(\n    event_type=\"my_app.transcribe\",\n    name=\"Transcribe\",\n    description=\"Transcribe this file\",\n    secret=os.environ[\"TRANSCRIBE_CUSTOM_ACTION_SECRET\"]\n)\nasync def transcribe_file(event: ActionEvent):\n    pass\n</code></pre>"},{"location":"usage/custom_actions/#parameters","title":"Parameters","text":"<ul> <li><code>event_type</code> (str): Unique identifier for this action</li> <li><code>name</code> (str): Display name in Frame.io UI</li> <li><code>description</code> (str): Description shown in UI</li> <li><code>secret</code> (str | None, optional): Signing secret from Frame.io. If not provided, falls back to the <code>CUSTOM_ACTION_SECRET</code> environment variable. Explicit parameter takes precedence over environment variable.</li> <li><code>require_user_auth</code> (bool, optional): Require user to authenticate via Adobe Login OAuth. When <code>True</code>, users must sign in before the action executes. See User Authentication for details.</li> </ul> <p>Environment Variables</p> <p>Single action: Use the default <code>CUSTOM_ACTION_SECRET</code> environment variable and omit the <code>secret</code> parameter.</p> <p>Multiple actions with different secrets: Pass each secret explicitly via <code>secret=os.environ[\"ACTION_NAME_CUSTOM_ACTION_SECRET\"]</code> to keep secrets out of your code while supporting multiple action configurations.</p>"},{"location":"usage/custom_actions/#action-event-object","title":"Action Event Object","text":"<p>The <code>ActionEvent</code> object provides access to action data:</p> <pre><code>from frameio_kit import ActionEvent\n\nasync def handler(event: ActionEvent):\n    print(event.type)           # \"my_app.analyze\"\n    print(event.resource_id)    # \"abc123\"\n    print(event.user.id)        # \"user_789\"\n    print(event.data)           # None (first call) or dict (form submission)\n</code></pre>"},{"location":"usage/custom_actions/#response-types","title":"Response Types","text":"<p>Custom Actions support two response types:</p>"},{"location":"usage/custom_actions/#message-simple-feedback","title":"<code>Message</code> - Simple Feedback","text":"<p>For actions that complete immediately without user input:</p> <pre><code>from frameio_kit import Message\n\nreturn Message(\n    title=\"Task Complete\",\n    description=\"Your file has been processed successfully!\"\n)\n</code></pre>"},{"location":"usage/custom_actions/#form-user-input","title":"<code>Form</code> - User Input","text":"<p>For actions that need user input:</p> <pre><code>from frameio_kit import Form, TextField\n\nreturn Form(\n    title=\"Configure Settings\",\n    description=\"Enter your preferences:\",\n    fields=[\n        TextField(label=\"Name\", name=\"name\", value=\"default\")\n    ]\n)\n</code></pre>"},{"location":"usage/custom_actions/#form-fields","title":"Form Fields","text":"Field Type Use Case Example <code>TextField</code> Single line text Names, titles, IDs <code>TextareaField</code> Multi-line text Comments, descriptions <code>SelectField</code> Choose from options Categories, platforms <code>CheckboxField</code> Checkbox toggle Yes/no, enable/disable <code>LinkField</code> URL link External resources"},{"location":"usage/custom_actions/#example-1-single-action-default-env-var","title":"Example 1: Single Action (Default Env Var)","text":"<pre><code>from frameio_kit import App, ActionEvent, Message\n\napp = App()\n\n# Single action - CUSTOM_ACTION_SECRET env var used automatically\n@app.on_action(\n    event_type=\"asset.notify\",\n    name=\"Notify Team\",\n    description=\"Send notification about this asset\"\n)\nasync def notify_team(event: ActionEvent):\n    print(f\"Notification sent for {event.resource_id} by {event.user.id}\")\n\n    # Send actual notification here\n    await send_notification(event.resource_id, event.user.id)\n\n    return Message(\n        title=\"Notification Sent\",\n        description=\"Your team has been notified about this asset.\"\n    )\n</code></pre>"},{"location":"usage/custom_actions/#example-2-multiple-actions-explicit-env-vars","title":"Example 2: Multiple Actions (Explicit Env Vars)","text":"<pre><code>import os\nfrom frameio_kit import App, ActionEvent, Message, Form, TextField, SelectField, SelectOption\n\napp = App()\n\nPLATFORMS = [\n    SelectOption(name=\"Twitter\", value=\"twitter\"),\n    SelectOption(name=\"Instagram\", value=\"instagram\"),\n]\n\n# Multiple actions with different secrets - use explicit env vars\n@app.on_action(\n    event_type=\"asset.publish\",\n    name=\"Publish Asset\",\n    description=\"Publish this asset to social media\",\n    secret=os.environ[\"PUBLISH_CUSTOM_ACTION_SECRET\"]\n)\nasync def publish_asset(event: ActionEvent):\n    if event.data:\n        platform = event.data.get(\"platform\")\n        caption = event.data.get(\"caption\")\n        print(f\"Publishing to {platform}: {caption}\")\n        return Message(title=\"Published!\", description=f\"Asset published to {platform} successfully.\")\n\n    return Form(\n        title=\"Publish to Social Media\",\n        description=\"Configure your post:\",\n        fields=[\n            SelectField(label=\"Platform\", name=\"platform\", options=PLATFORMS),\n            TextField(label=\"Caption\", name=\"caption\", value=\"Enter your caption...\")\n        ]\n    )\n\n@app.on_action(\n    event_type=\"asset.analyze\",\n    name=\"Analyze Asset\",\n    description=\"Perform AI analysis on this asset\",\n    secret=os.environ[\"ANALYZE_CUSTOM_ACTION_SECRET\"]\n)\nasync def analyze_asset(event: ActionEvent):\n    # Perform analysis\n    analysis_result = await perform_analysis(event.resource_id)\n\n    return Message(\n        title=\"Analysis Complete\",\n        description=f\"Analysis score: {analysis_result}\"\n    )\n</code></pre>"},{"location":"usage/custom_actions/#example-3-complex-form","title":"Example 3: Complex Form","text":"<pre><code>import os\nimport datetime\nfrom frameio_kit import App, ActionEvent, Message, Form, TextField, TextareaField, CheckboxField\n\napp = App()\n\n# Single action - use default CUSTOM_ACTION_SECRET\n@app.on_action(\n    event_type=\"asset.schedule\",\n    name=\"Schedule Review\",\n    description=\"Schedule a review for this asset\"\n)\nasync def schedule_review(event: ActionEvent):\n    if event.data:\n        reviewer = event.data.get(\"reviewer\")\n        due_date = event.data.get(\"due_date\")\n        urgent = event.data.get(\"urgent\", False)\n        notes = event.data.get(\"notes\", \"\")\n\n        priority = \"urgent\" if urgent else \"normal\"\n        print(f\"Scheduling {priority} review with {reviewer} by {due_date}\")\n\n        return Message(\n            title=\"Review Scheduled\",\n            description=f\"Review assigned to {reviewer} for {due_date}\"\n        )\n\n    return Form(\n        title=\"Schedule Review\",\n        description=\"Set up a review for this asset:\",\n        fields=[\n            TextField(label=\"Reviewer Email\", name=\"reviewer\", value=\"reviewer@company.com\"),\n            TextField(label=\"Due Date\", name=\"due_date\", value=datetime.date.today().isoformat()),\n            CheckboxField(label=\"Urgent\", name=\"urgent\", value=False),\n            TextareaField(label=\"Notes\", name=\"notes\", value=\"Additional instructions...\")\n        ]\n    )\n</code></pre>"},{"location":"usage/custom_actions/#dynamic-secret-resolution","title":"Dynamic Secret Resolution","text":"<p>When you need to resolve action secrets dynamically (e.g., from a database for multi-tenant applications), use secret resolvers.</p>"},{"location":"usage/custom_actions/#decorator-level-resolver","title":"Decorator-Level Resolver","text":"<p>Provide an async function that receives the <code>ActionEvent</code> and returns the secret:</p> <pre><code>from frameio_kit import App, ActionEvent, Message\n\napp = App()\n\nasync def resolve_action_secret(event: ActionEvent) -&gt; str:\n    \"\"\"Resolve secret based on account ID or resource.\"\"\"\n    return await db.get_action_secret(account_id=event.account_id)\n\n# Use the resolver for this specific action\n@app.on_action(\n    event_type=\"my_app.process\",\n    name=\"Process File\",\n    description=\"Process this file\",\n    secret=resolve_action_secret\n)\nasync def process_file(event: ActionEvent):\n    return Message(title=\"Processing\", description=\"File is being processed\")\n</code></pre>"},{"location":"usage/custom_actions/#secret-resolution-precedence","title":"Secret Resolution Precedence","text":"<ol> <li>Explicit string secret (<code>secret=\"...\"</code>)</li> <li>Decorator-level resolver (<code>secret=my_resolver</code>)</li> <li>Install system resolver (when <code>install=True</code>, secrets are auto-managed)</li> <li>Environment variable (<code>CUSTOM_ACTION_SECRET</code>)</li> </ol>"},{"location":"usage/custom_actions/#setting-up-custom-actions-in-frameio","title":"Setting Up Custom Actions in Frame.io","text":"<ol> <li>Go to Workspace Settings in Frame.io</li> <li>Navigate to Actions section  </li> <li>Create a new Custom Action:</li> <li>Name: Display name in UI</li> <li>Description: What the action does</li> <li>Event: Must match your <code>event_type</code> parameter</li> <li>URL: Your application's public endpoint</li> <li>Secret: Copy the generated secret to your environment variables</li> <li>Test the action by right-clicking on an asset</li> </ol>"},{"location":"usage/custom_actions/#best-practices","title":"Best Practices","text":"<ol> <li>Keep actions focused - Each action should do one thing well</li> <li>Provide clear feedback - Use descriptive titles and messages</li> <li>Handle form validation - Check required fields and provide helpful errors</li> <li>Use meaningful names - Make event types and display names descriptive</li> <li>Test thoroughly - Custom actions are user-facing, so they need to work reliably</li> <li>Consider user experience - Keep forms simple and intuitive</li> </ol>"},{"location":"usage/custom_actions/#two-step-process","title":"Two-Step Process","text":"<p>Custom Actions use a two-step process when returning forms:</p> <ol> <li>Initial call - <code>event.data</code> is <code>None</code>, return a <code>Form</code></li> <li>Form submission - <code>event.data</code> contains the submitted values, return a <code>Message</code></li> </ol> <pre><code>async def my_action(event: ActionEvent):\n    if event.data is None:\n        # First call - show the form\n        return Form(title=\"My Form\", description=\"Fill out the form.\", fields=[...])\n    else:\n        # Second call - process the form data\n        return Message(title=\"Done\", description=\"Form processed!\")\n</code></pre>"},{"location":"usage/getting_started/","title":"Getting Started","text":"<p>Welcome to <code>frameio-kit</code>! This guide will take you from zero to a working Frame.io integration in just a few minutes.</p>"},{"location":"usage/getting_started/#what-youll-build","title":"What You'll Build","text":"<p>By the end of this guide, you'll have:</p> <ul> <li>\u2705 A running Frame.io integration</li> <li>\u2705 A custom action that responds to user clicks</li> <li>\u2705 A webhook that processes file events</li> <li>\u2705 An understanding of the core concepts</li> </ul>"},{"location":"usage/getting_started/#prerequisites","title":"Prerequisites","text":"<p>Before you start, make sure you have:</p> <ul> <li>Python 3.13+ installed</li> <li>A Frame.io account with workspace access</li> <li>Basic Python knowledge (async/await helpful but not required)</li> </ul>"},{"location":"usage/getting_started/#step-1-installation","title":"Step 1: Installation","text":"<p>Create a new project directory and install <code>frameio-kit</code>:</p> <pre><code># Create project directory\nmkdir my-frameio-app\ncd my-frameio-app\n\n# Install frameio-kit (we recommend uv for fast, reliable installs)\nuv add frameio-kit uvicorn\n\n# Or with pip\npip install frameio-kit uvicorn\n</code></pre>"},{"location":"usage/getting_started/#optional-dependencies","title":"Optional Dependencies","text":"<p>frameio-kit provides optional extras for additional features:</p> Extra Command Description <code>install</code> <code>pip install frameio-kit[install]</code> Installation system for self-service workspace onboarding <code>dynamodb</code> <code>pip install frameio-kit[dynamodb]</code> DynamoDB storage backend for multi-server deployments <p>You can combine extras: <code>pip install frameio-kit[install,dynamodb]</code></p>"},{"location":"usage/getting_started/#step-2-create-your-application","title":"Step 2: Create Your Application","text":"<p>Create a file named <code>main.py</code> with the following code:</p> <pre><code>from frameio_kit import App, ActionEvent, WebhookEvent, Message\n\napp = App()\n\n# Custom Action: Responds to user clicks in Frame.io\n# CUSTOM_ACTION_SECRET env var will be used automatically\n@app.on_action(\n    event_type=\"greeting.say_hello\",\n    name=\"Say Hello\",\n    description=\"A simple greeting action\"\n)\nasync def on_greeting(event: ActionEvent):\n    print(f\"Hello from {event.user.id}!\")\n    return Message(\n        title=\"Greetings!\",\n        description=\"Hello from your first frameio-kit app!\"\n    )\n\n# Webhook: Responds to file events from Frame.io\n# WEBHOOK_SECRET env var will be used automatically\n@app.on_webhook(\"file.ready\")\nasync def on_file_ready(event: WebhookEvent):\n    print(f\"File {event.resource_id} is ready!\")\n</code></pre> <p>What this code does:</p> <ul> <li>Custom Action - Creates a \"Say Hello\" menu item in Frame.io that displays a greeting when clicked</li> <li>Webhook - Listens for <code>file.ready</code> events and prints the file ID when files are processed</li> <li><code>App()</code> - Initializes your Frame.io integration</li> <li><code>Message</code> - Returned from the custom action handler to display a response in the Frame.io UI</li> <li>Environment Variables - <code>CUSTOM_ACTION_SECRET</code> and <code>WEBHOOK_SECRET</code> are automatically loaded from environment</li> </ul> <p>Learn more about Custom Actions and Webhooks</p>"},{"location":"usage/getting_started/#step-3-expose-your-server","title":"Step 3: Expose Your Server","text":"<p>Frame.io needs a public URL to send events to your application. For local development, use ngrok:</p> <pre><code>ngrok http 8000\n</code></pre> <p>Copy the HTTPS forwarding URL (e.g., <code>https://abc123.ngrok-free.app</code>) \u2013 you'll need it for Frame.io configuration.</p>"},{"location":"usage/getting_started/#step-4-configure-frameio","title":"Step 4: Configure Frame.io","text":""},{"location":"usage/getting_started/#create-a-custom-action","title":"Create a Custom Action","text":"<ol> <li>In Frame.io, navigate to Account Settings \u2192 Actions</li> <li>Click \"New Action\" and configure:</li> <li>Name: <code>Say Hello</code></li> <li>Event: <code>greeting.say_hello</code></li> <li>URL: Your ngrok URL</li> <li>Workspace: Choose the workspace</li> <li>Copy the signing secret</li> </ol>"},{"location":"usage/getting_started/#create-a-webhook","title":"Create a Webhook","text":"<ol> <li>In the same settings page, go to Webhooks</li> <li>Click \"New Webhook\" and configure:</li> <li>Webhook Name: On file ready</li> <li>Event Types: Select <code>file.ready</code></li> <li>Webhook URL: Your ngrok URL</li> <li>Workspace: Choose the workspace</li> <li>Copy the signing secret</li> </ol>"},{"location":"usage/getting_started/#set-environment-variables","title":"Set Environment Variables","text":"<p>Create a <code>.env</code> file with the secrets from Frame.io:</p> <pre><code>CUSTOM_ACTION_SECRET=your-action-secret-here\nWEBHOOK_SECRET=your-webhook-secret-here\n</code></pre> <p>Secret Configuration</p> <p>This example uses the default <code>CUSTOM_ACTION_SECRET</code> and <code>WEBHOOK_SECRET</code> environment variables, which is recommended when you have one action and one webhook.</p> <p>For multiple secrets: Pass each secret explicitly via environment variables: <pre><code>@app.on_webhook(\"file.ready\", secret=os.environ[\"FILES_WEBHOOK_SECRET\"])\n@app.on_action(\"my_app.analyze\", name=\"Analyze\", description=\"Analyze file\", secret=os.environ[\"ANALYZE_CUSTOM_ACTION_SECRET\"])\n</code></pre></p> <p>For dynamic secrets (e.g., multi-tenant apps, database-backed secrets): See Secret Resolution Precedence in the App Configuration guide, or use the Installation System for automatic secret management.</p>"},{"location":"usage/getting_started/#step-5-run-your-application","title":"Step 5: Run Your Application","text":"<pre><code>uvicorn main:app --reload\n</code></pre>"},{"location":"usage/getting_started/#step-6-test-your-integration","title":"Step 6: Test Your Integration","text":"<p>Test the Custom Action:</p> <ol> <li>Right-click any asset in Frame.io</li> <li>Select \"Say Hello\" from the menu</li> <li>See the greeting message appear</li> </ol> <p>Test the Webhook:</p> <ol> <li>Upload a file to Frame.io</li> <li>Wait for it to reach \"Ready\" status</li> <li>Check your terminal for the webhook message</li> </ol>"},{"location":"usage/getting_started/#what-youve-built","title":"What You've Built","text":"<p>You now have a working Frame.io integration that:</p> <ul> <li>Responds to user clicks with custom actions</li> <li>Processes Frame.io events with webhooks</li> <li>Returns feedback to users in the Frame.io UI</li> <li>Verifies requests with signature authentication</li> </ul>"},{"location":"usage/getting_started/#next-steps","title":"Next Steps","text":"<p>Explore more features to build powerful integrations:</p> <ul> <li>App Configuration - Configure middleware, OAuth, and dynamic secret resolution</li> <li>Webhooks - Learn about different event types and best practices</li> <li>Custom Actions - Build interactive forms and workflows</li> <li>Client API - Make authenticated calls to Frame.io's API</li> <li>Middleware - Add logging, metrics, and error handling</li> <li>User Authentication - Enable Adobe Login OAuth for user-specific actions</li> </ul>"},{"location":"usage/getting_started/#troubleshooting","title":"Troubleshooting","text":"<p>\"Invalid signature\" error</p> <ul> <li>Verify secrets in <code>.env</code> match those from Frame.io</li> <li>Ensure you're using the correct secret for each handler</li> </ul> <p>Can't see the custom action</p> <ul> <li>Refresh the Frame.io page</li> <li>Check the action is enabled in workspace settings</li> </ul> <p>Webhook not triggering</p> <ul> <li>Verify ngrok is running and the URL is correct</li> <li>Check event types match exactly between Frame.io and your code</li> </ul> <p>For more help, see the API Reference or check Frame.io's developer documentation.</p>"},{"location":"usage/installation/","title":"Installation System","text":"<p>Self-service installation pages for workspace admins. Auto-discovers handlers from decorators, creates webhooks and custom actions via the Frame.io API, and manages signing secrets \u2014 all with a branded UI.</p>"},{"location":"usage/installation/#when-to-use","title":"When to Use","text":"<p>Use the installation system when you need to:</p> <ul> <li>Deploy a multi-tenant app across multiple workspaces and accounts</li> <li>Provide a self-service UI for workspace admins to install your integration</li> <li>Automatically manage webhook and custom action lifecycle (create, update, uninstall)</li> <li>Eliminate manual API registration and secret management</li> </ul> <p>For single-workspace or development setups, static secrets with environment variables are sufficient.</p>"},{"location":"usage/installation/#quick-start","title":"Quick Start","text":""},{"location":"usage/installation/#1-install-the-optional-dependency","title":"1. Install the Optional Dependency","text":"<pre><code>pip install frameio-kit[install]\n</code></pre>"},{"location":"usage/installation/#2-configure-your-app","title":"2. Configure Your App","text":"<pre><code>import os\nfrom frameio_kit import App, OAuthConfig\n\napp = App(\n    oauth=OAuthConfig(\n        client_id=os.environ[\"ADOBE_CLIENT_ID\"],\n        client_secret=os.environ[\"ADOBE_CLIENT_SECRET\"],\n    ),\n    install=True,\n    name=\"Transcription Bot\",\n    description=\"Automatically transcribes videos uploaded to Frame.io.\",\n    primary_color=\"#6366f1\",\n)\n\n# Handlers are auto-discovered \u2014 no secret parameter needed\n@app.on_webhook(\"file.ready\")\nasync def on_file_ready(event):\n    ...\n\n@app.on_action(\"myapp.transcribe\", name=\"Transcribe\", description=\"Transcribe video audio\")\nasync def on_transcribe(event):\n    ...\n</code></pre> <p>That's it. Run with <code>uvicorn</code> and visit <code>/install</code> \u2014 the branded installation page is automatically available.</p> <p>No Secret Parameter Needed</p> <p>When <code>install=True</code>, signing secrets are automatically resolved from installation records. You don't need to pass <code>secret</code> to <code>@app.on_webhook</code> or <code>@app.on_action</code>.</p> <p>Storage</p> <p>Using <code>MemoryStorage</code> (the default) means installation records are lost on app restart. Use <code>DynamoDBStorage</code> or a custom <code>Storage</code> implementation for production deployments.</p>"},{"location":"usage/installation/#3-register-the-callback-url","title":"3. Register the Callback URL","text":"<p>In the Adobe Developer Console, add <code>https://yourapp.com/install/callback</code> as a redirect URL for your OAuth credential.</p>"},{"location":"usage/installation/#how-it-works","title":"How It Works","text":"<ol> <li> <p>At startup: The system introspects registered <code>@app.on_webhook</code> and <code>@app.on_action</code> handlers to build a handler manifest \u2014 a description of what needs to be installed.</p> </li> <li> <p>Admin visits <code>/install</code>: A branded landing page shows your app name, description, and what will be installed (webhook events, custom actions).</p> </li> <li> <p>OAuth flow: Admin clicks \"Login with Adobe\" \u2192 authenticates \u2192 selects an account and workspace.</p> </li> <li> <p>Install: The system uses the admin's OAuth token to call the Frame.io API:</p> <ul> <li>Creates a consolidated webhook for all webhook event types</li> <li>Creates individual custom actions for each action handler</li> <li>Stores the returned signing secrets (encrypted at rest) in your Storage backend</li> </ul> </li> <li> <p>Events arrive: When Frame.io sends events, the <code>InstallationSecretResolver</code> automatically looks up the correct signing secret from the installation record \u2014 no manual configuration needed.</p> </li> </ol>"},{"location":"usage/installation/#user-journeys","title":"User Journeys","text":""},{"location":"usage/installation/#installing","title":"Installing","text":"<ol> <li>Workspace admin navigates to <code>https://yourapp.com/install</code></li> <li>Sees branded landing page with app description and what will be installed</li> <li>Clicks \"Login with Adobe\" \u2192 OAuth flow</li> <li>Selects account and workspace from dropdowns</li> <li>Clicks \"Install\" \u2192 webhooks and custom actions are created</li> <li>Success confirmation shown</li> </ol>"},{"location":"usage/installation/#updating","title":"Updating","text":"<p>When you change handlers in code (add/remove webhooks or actions, rename an action) and redeploy:</p> <ol> <li>Admin visits <code>/install</code>, authenticates, selects their workspace</li> <li>Status panel shows \"Update Available\" with a diff summary:<ul> <li><code>+ Webhook event: comment.created</code></li> <li><code>+ Action: \"Export to S3\"</code></li> <li><code>- Action: \"Old Export\" (will be removed)</code></li> <li><code>~ Action: \"Transcribe\" (description updated)</code></li> </ul> </li> <li>Admin clicks \"Update\"</li> <li>System performs targeted API calls \u2014 only creating, deleting, or patching what changed</li> </ol> <p>Secrets Survive Updates</p> <p>Frame.io only returns signing secrets at creation time. The system preserves existing secrets for updated resources and only assigns fresh secrets to newly created ones.</p>"},{"location":"usage/installation/#uninstalling","title":"Uninstalling","text":"<ol> <li>Admin visits <code>/install</code>, selects workspace, sees current installation</li> <li>Clicks \"Uninstall\" \u2192 all webhooks and custom actions are deleted</li> <li>Installation records removed from Storage</li> </ol>"},{"location":"usage/installation/#configuration-reference","title":"Configuration Reference","text":"<p>These parameters are passed directly to <code>App(...)</code>:</p> Parameter Type Default Description <code>install</code> <code>bool</code> <code>False</code> Enable the self-service install page <code>name</code> <code>str \\| None</code> <code>None</code> Display name in install UI and auth pages <code>description</code> <code>str</code> <code>\"\"</code> Description shown on landing page <code>logo_url</code> <code>str \\| None</code> <code>None</code> Partner logo URL <code>primary_color</code> <code>str</code> <code>\"#6366f1\"</code> Branding primary color (hex) <code>accent_color</code> <code>str</code> <code>\"#8b5cf6\"</code> Branding accent color (hex) <code>custom_css</code> <code>str \\| None</code> <code>None</code> Raw CSS injected into templates <code>show_powered_by</code> <code>bool</code> <code>True</code> Show \"Powered by frameio-kit\" footer <code>base_url</code> <code>str \\| None</code> <code>None</code> Public URL override (else inferred from request) <code>allowed_accounts</code> <code>list[str] \\| None</code> <code>None</code> Account IDs allowed to install (None = all) <code>install_session_ttl</code> <code>int</code> <code>1800</code> Install session TTL in seconds (30 min)"},{"location":"usage/installation/#branding","title":"Branding","text":"<p>Customize the installation pages with your brand identity:</p> <pre><code>app = App(\n    oauth=OAuthConfig(...),\n    install=True,\n    name=\"My Video Tool\",\n    description=\"AI-powered video analysis for your team.\",\n    logo_url=\"https://myapp.com/logo.png\",\n    primary_color=\"#1a73e8\",\n    accent_color=\"#34a853\",\n    custom_css=\".fk-header { font-family: 'Inter', sans-serif; }\",\n    show_powered_by=False,\n)\n</code></pre> <p>The UI uses CSS custom properties (<code>--fk-primary</code>, <code>--fk-accent</code>, etc.) derived from your configuration, combined with Tailwind CSS for layout and spacing.</p>"},{"location":"usage/installation/#restricting-access","title":"Restricting Access","text":"<p>By default, any Frame.io user who authenticates can install the app to any account they belong to. To restrict installation to specific accounts, use <code>allowed_accounts</code>:</p> <pre><code>app = App(\n    oauth=OAuthConfig(...),\n    install=True,\n    name=\"Internal Tool\",\n    allowed_accounts=[\n        \"12345678-1234-1234-1234-123456789abc\",  # Production account\n    ],\n)\n</code></pre> <p>When set, only the listed accounts appear in the account dropdown and install/uninstall requests for other accounts are rejected. This is useful for internal tools that should only run within your own organization's accounts.</p>"},{"location":"usage/installation/#storage","title":"Storage","text":"<p>Installation data uses the same <code>Storage</code> backend as OAuth token management. Records are keyed by <code>install:{account_id}:{workspace_id}</code>.</p>"},{"location":"usage/installation/#development-memorystorage","title":"Development: MemoryStorage","text":"<pre><code># Default \u2014 no storage parameter needed\napp = App(\n    oauth=OAuthConfig(...),\n    install=True,\n    name=\"My App\",\n)\n</code></pre>"},{"location":"usage/installation/#production-dynamodbstorage","title":"Production: DynamoDBStorage","text":"<p>Install the optional dependencies:</p> <pre><code>pip install frameio-kit[install,dynamodb]\n</code></pre> <pre><code>from frameio_kit import DynamoDBStorage\n\nstorage = DynamoDBStorage(table_name=\"frameio-app-data\")\n\napp = App(\n    oauth=OAuthConfig(...),\n    storage=storage,\n    install=True,\n    name=\"My App\",\n)\n</code></pre>"},{"location":"usage/installation/#routes","title":"Routes","text":"<p>The installation system mounts these routes:</p> Method Path Purpose <code>GET</code> <code>/install</code> Landing page <code>GET</code> <code>/install/login</code> Initiate OAuth for install <code>GET</code> <code>/install/callback</code> Handle OAuth callback <code>GET</code> <code>/install/workspaces</code> HTMX: load workspaces for selected account <code>GET</code> <code>/install/status</code> HTMX: installation status for selected workspace <code>POST</code> <code>/install/execute</code> HTMX: perform install or update <code>POST</code> <code>/install/uninstall</code> HTMX: perform uninstall"},{"location":"usage/installation/#security","title":"Security","text":"<ul> <li>Secrets encrypted at rest \u2014 Signing secrets are encrypted with Fernet (AES-128 + HMAC) before storage</li> <li>Session encryption \u2014 OAuth access tokens in install sessions are also encrypted</li> <li>Signed cookies \u2014 Session cookies are cryptographically signed with <code>HttpOnly</code>, <code>Secure</code>, <code>SameSite=Lax</code>, and <code>Path=/install</code></li> <li>Input validation \u2014 Account and workspace IDs are validated as UUIDs before API calls</li> <li>Auto-escaping \u2014 Jinja2 templates use <code>autoescape=True</code> to prevent XSS</li> </ul> <p>URL Inference</p> <p>When <code>base_url</code> is not set, the public URL for webhooks is inferred from the request's <code>Host</code> header. Set <code>base_url</code> explicitly in production, especially behind reverse proxies.</p>"},{"location":"usage/installation/#best-practices","title":"Best Practices","text":"<ul> <li>Always use persistent storage (e.g., <code>DynamoDBStorage</code>) in production</li> <li>Set <code>base_url</code> explicitly when behind a reverse proxy</li> <li>Test the install flow in development using ngrok or similar</li> <li>The installing user needs workspace admin access in Frame.io</li> </ul>"},{"location":"usage/installation/#next-steps","title":"Next Steps","text":"<ul> <li>User Authentication \u2014 OAuth for user-specific API calls</li> <li>Custom Actions \u2014 Build interactive workflows</li> <li>Webhooks \u2014 React to Frame.io events</li> <li>API Reference \u2014 Complete type documentation</li> </ul>"},{"location":"usage/middleware/","title":"Middleware","text":"<p>Middleware provides a powerful way to add cross-cutting concerns to your Frame.io integration without cluttering your handler functions. You can use middleware for logging, authentication, metrics collection, error handling, and more.</p>"},{"location":"usage/middleware/#why-use-middleware","title":"Why Use Middleware?","text":"<p>Middleware is particularly useful when you need to:</p> <ul> <li>Add logging or monitoring to all requests</li> <li>Implement authentication or authorization checks</li> <li>Collect metrics about request processing times</li> <li>Handle errors consistently across all handlers</li> <li>Add request/response transformation logic</li> <li>Implement rate limiting or other security measures</li> </ul> <p>Instead of duplicating this logic in every handler, middleware allows you to write it once and apply it globally.</p>"},{"location":"usage/middleware/#how-middleware-works","title":"How Middleware Works","text":"<p>Middleware in <code>frameio-kit</code> follows a chain-of-responsibility pattern. When an event is received, it flows through each middleware in the order they were registered, then to your handler, and finally back through the middleware in reverse order.</p> <pre><code>Request \u2192 Middleware 1 \u2192 Middleware 2 \u2192 Handler \u2192 Middleware 2 \u2192 Middleware 1 \u2192 Response\n</code></pre>"},{"location":"usage/middleware/#middleware-hooks","title":"Middleware Hooks","text":"<p>The <code>Middleware</code> base class provides three hooks you can override:</p>"},{"location":"usage/middleware/#__call__event-next","title":"<code>__call__(event, next)</code>","text":"<p>The main entry point that runs for every event (both webhooks and actions). This is where you implement logic that should apply universally.</p> <pre><code>async def __call__(self, event: AnyEvent, next: NextFunc) -&gt; AnyResponse:\n    # Code here runs before every event\n    result = await next(event)  # Call the next middleware or handler\n    # Code here runs after every event\n    return result\n</code></pre>"},{"location":"usage/middleware/#on_webhookevent-next","title":"<code>on_webhook(event, next)</code>","text":"<p>Runs only for webhook events. This is called automatically by the base <code>__call__</code> method when the event is a <code>WebhookEvent</code>.</p> <pre><code>async def on_webhook(self, event: WebhookEvent, next: NextFunc) -&gt; AnyResponse:\n    # Code here runs only for webhook events\n    result = await next(event)\n    return result\n</code></pre>"},{"location":"usage/middleware/#on_actionevent-next","title":"<code>on_action(event, next)</code>","text":"<p>Runs only for custom action events. This is called automatically by the base <code>__call__</code> method when the event is an <code>ActionEvent</code>.</p> <pre><code>async def on_action(self, event: ActionEvent, next: NextFunc) -&gt; AnyResponse:\n    # Code here runs only for action events\n    result = await next(event)\n    return result\n</code></pre>"},{"location":"usage/middleware/#important-overriding-__call__","title":"Important: Overriding <code>__call__</code>","text":"<p>When you override <code>__call__</code>, you completely replace the base implementation. This means:</p> <ul> <li>Without <code>super()</code>: The <code>on_webhook</code> and <code>on_action</code> methods on the same middleware class will not be called</li> <li>With <code>super()</code>: The original dispatch logic is preserved, so <code>on_webhook</code> and <code>on_action</code> will still be called</li> </ul>"},{"location":"usage/middleware/#setting-up-middleware","title":"Setting Up Middleware","text":"<p>To use middleware, pass a list of middleware instances when creating your <code>App</code>:</p> <pre><code>from frameio_kit import App, Middleware\n\napp = App(\n    token=os.getenv(\"FRAMEIO_TOKEN\"),\n    middleware=[\n        LoggingMiddleware(),\n        TimingMiddleware(),\n        # Add more middleware here\n    ]\n)\n</code></pre>"},{"location":"usage/middleware/#example-1-using-__call__-for-universal-logic","title":"Example 1: Using <code>__call__</code> for Universal Logic","text":"<pre><code>import time\nfrom frameio_kit import App, Middleware, WebhookEvent, Message\nfrom frameio_kit import AnyEvent, NextFunc, AnyResponse\n\nclass TimingMiddleware(Middleware):\n    async def __call__(self, event: AnyEvent, next: NextFunc) -&gt; AnyResponse:\n        start_time = time.monotonic()\n\n        try:\n            return await next(event)\n        finally:\n            duration = time.monotonic() - start_time\n            print(f\"Completed in {duration:.2f}s\")\n\n# Usage\napp = App(\n    token=os.getenv(\"FRAMEIO_TOKEN\"),\n    middleware=[TimingMiddleware()]\n)\n\n@app.on_webhook(\"file.ready\", secret=os.environ[\"WEBHOOK_SECRET\"])\nasync def on_file_ready(event: WebhookEvent):\n    print(\"File ready\")\n</code></pre>"},{"location":"usage/middleware/#example-2-using-specific-hooks","title":"Example 2: Using Specific Hooks","text":"<pre><code>from frameio_kit import App, Middleware, WebhookEvent, ActionEvent, Message\nfrom frameio_kit import NextFunc, AnyResponse\n\nclass LoggingMiddleware(Middleware):\n    async def on_webhook(self, event: WebhookEvent, next: NextFunc) -&gt; AnyResponse:\n        print(f\"Webhook: {event.type} for {event.resource_id}\")\n        return await next(event)\n\n    async def on_action(self, event: ActionEvent, next: NextFunc) -&gt; AnyResponse:\n        print(f\"Action: {event.type} by {event.user.id}\")\n        return await next(event)\n\nclass ValidationMiddleware(Middleware):\n    async def on_webhook(self, event: WebhookEvent, next: NextFunc) -&gt; AnyResponse:\n        if not event.resource_id:\n            raise ValueError(\"Missing resource_id\")\n        return await next(event)\n\n# Usage\napp = App(\n    token=os.getenv(\"FRAMEIO_TOKEN\"),\n    middleware=[LoggingMiddleware(), ValidationMiddleware()]\n)\n\n@app.on_webhook(\"file.ready\", secret=os.environ[\"WEBHOOK_SECRET\"])\nasync def on_file_ready(event: WebhookEvent):\n    print(\"File ready\")\n\n@app.on_action(\"my_app.analyze\", name=\"Analyze\", description=\"Analyze file\", secret=os.environ[\"ACTION_SECRET\"])\nasync def analyze_file(event: ActionEvent):\n    return Message(title=\"Analysis Complete\", description=\"Done!\")\n</code></pre>"},{"location":"usage/middleware/#best-practices","title":"Best Practices","text":"<ol> <li> <p>Order matters: Middleware runs in the order you register it. Put error handling middleware first.</p> </li> <li> <p>Keep middleware focused: Each middleware should have a single responsibility.</p> </li> <li> <p>Use <code>super().__call__()</code> when needed: If you override <code>__call__</code> but still want the automatic dispatch to <code>on_webhook</code>/<code>on_action</code>, use <code>super().__call__(event, next)</code>.</p> </li> <li> <p>Handle exceptions gracefully: Consider whether to re-raise exceptions or return default responses and when to use <code>try</code>/<code>finally</code> to ensure cleanup.</p> </li> <li> <p>Make middleware configurable: Use <code>__init__</code> to accept configuration parameters.</p> </li> <li> <p>Test your middleware: Write unit tests to ensure your middleware behaves correctly in isolation.</p> </li> </ol>"},{"location":"usage/middleware/#advanced-patterns","title":"Advanced Patterns","text":""},{"location":"usage/middleware/#conditional-middleware","title":"Conditional Middleware","text":"<p>You can create middleware that only runs under certain conditions:</p> <pre><code>class ConditionalMiddleware(Middleware):\n    def __init__(self, condition_func):\n        self.condition_func = condition_func\n\n    async def __call__(self, event: AnyEvent, next: NextFunc) -&gt; AnyResponse:\n        if self.condition_func(event):\n            # Only run middleware logic if condition is met\n            print(f\"Condition met for {event.type}\")\n        return await next(event)\n\n# Usage\napp = App(\n    middleware=[\n        ConditionalMiddleware(lambda e: e.type.startswith(\"file.\")),\n    ]\n)\n</code></pre>"},{"location":"usage/middleware/#middleware-with-state","title":"Middleware with State","text":"<p>Middleware can maintain state across requests:</p> <pre><code>class RateLimitMiddleware(Middleware):\n    def __init__(self, max_requests_per_minute=60):\n        self.max_requests = max_requests_per_minute\n        self.requests = {}  # Track requests by resource_id\n\n    async def __call__(self, event: AnyEvent, next: NextFunc) -&gt; AnyResponse:\n        current_time = time.time()\n        resource_id = event.resource_id\n\n        # Clean old entries\n        self.requests[resource_id] = [\n            req_time for req_time in self.requests.get(resource_id, [])\n            if current_time - req_time &lt; 60\n        ]\n\n        # Check rate limit\n        if len(self.requests.get(resource_id, [])) &gt;= self.max_requests:\n            raise Exception(f\"Rate limit exceeded for resource {resource_id}\")\n\n        # Record this request\n        self.requests.setdefault(resource_id, []).append(current_time)\n\n        return await next(event)\n</code></pre> <p>This comprehensive middleware system gives you the flexibility to add powerful cross-cutting concerns to your Frame.io integrations while keeping your handler code clean and focused.</p>"},{"location":"usage/mounting/","title":"Mounting to Existing Applications","text":"<p>You can mount your frameio-kit <code>App</code> into any existing ASGI-compatible application without changing your existing code. Since <code>App</code> is fully ASGI-compliant, it integrates seamlessly with frameworks like FastAPI, Starlette, Quart, and any other ASGI server.</p> <p>ASGI Compatibility</p> <p>The examples below use FastAPI, but the same mounting approach works with any ASGI-compatible framework. Simply use your framework's mount or route mounting mechanism.</p>"},{"location":"usage/mounting/#why-mount-to-an-existing-application","title":"Why Mount to an Existing Application?","text":"<p>Mounting to an existing application is useful when you want to:</p> <ul> <li>Consolidate services \u2013 Run your Frame.io integration alongside existing HTTP APIs.</li> <li>Share infrastructure \u2013 Reuse middleware, logging, and monitoring from your existing app.</li> <li>Unified deployment \u2013 Deploy one application instead of multiple services.</li> <li>Common endpoints \u2013 Provide health checks, metrics, and other shared endpoints.</li> </ul>"},{"location":"usage/mounting/#exposed-routes","title":"Exposed Routes","text":"<p>Before mounting, understand what routes your frameio-kit <code>App</code> exposes. The paths below are relative to the mount point (for example, <code>/frameio</code> if you mount at that prefix):</p>"},{"location":"usage/mounting/#always-available","title":"Always Available","text":"<ul> <li><code>POST /</code> - Main webhook and custom action endpoint</li> </ul>"},{"location":"usage/mounting/#oauth-routes-when-configured","title":"OAuth Routes (when configured)","text":"<ul> <li><code>GET /auth/login</code> - Initiates Adobe Login OAuth flow</li> <li><code>GET /auth/callback</code> - Handles OAuth callback</li> </ul> <p>OAuth Routes</p> <p>OAuth routes are only available when you configure the <code>App</code> with an <code>OAuthConfig</code>. See User Authentication for details.</p>"},{"location":"usage/mounting/#mounting-options","title":"Mounting Options","text":""},{"location":"usage/mounting/#option-1-mount-at-a-path-prefix-recommended","title":"Option 1: Mount at a Path Prefix (Recommended)","text":"<p>Mount your frameio-kit <code>App</code> at a specific path prefix to keep routes organized:</p> <pre><code>from contextlib import asynccontextmanager\nfrom fastapi import FastAPI\nfrom frameio_kit import App, WebhookEvent, ActionEvent, Message\n\n# Your frameio-kit app\nframeio_app = App()\n\n@frameio_app.on_webhook(\"file.ready\")\nasync def on_file_ready(event: WebhookEvent):\n    print(f\"File {event.resource_id} is ready!\")\n\n@frameio_app.on_action(\"my_app.process\", name=\"Process\", description=\"Process this file\")\nasync def process_file(event: ActionEvent):\n    return Message(title=\"Processing\", description=\"File is being processed\")\n\n# Lifespan to clean up frameio-kit resources on shutdown\n@asynccontextmanager\nasync def lifespan(app):\n    yield\n    await frameio_app.close()\n\n# Your existing FastAPI app\nfastapi_app = FastAPI(lifespan=lifespan)\n\n# Mount at /frameio prefix\nfastapi_app.mount(\"/frameio\", frameio_app)\n\n# Your existing FastAPI routes work normally\n@fastapi_app.get(\"/\")\nasync def root():\n    return {\"message\": \"Hello World\"}\n\n@fastapi_app.get(\"/health\")\nasync def health():\n    return {\"status\": \"healthy\"}\n</code></pre> <p>With this setup:</p> <ul> <li>Frame.io webhooks/actions \u2192 <code>https://your-domain.com/frameio/</code></li> <li>OAuth login (if enabled) \u2192 <code>https://your-domain.com/frameio/auth/login</code></li> <li>OAuth callback (if enabled) \u2192 <code>https://your-domain.com/frameio/auth/callback</code></li> <li>Your routes remain at their original paths</li> </ul>"},{"location":"usage/mounting/#option-2-mount-at-root-path","title":"Option 2: Mount at Root Path","text":"<p>If you want Frame.io events at the root path, mount at <code>/</code>:</p> <pre><code>from contextlib import asynccontextmanager\nfrom fastapi import FastAPI\nfrom frameio_kit import App, WebhookEvent\n\nframeio_app = App()\n\n@frameio_app.on_webhook(\"file.ready\")\nasync def on_file_ready(event: WebhookEvent):\n    print(f\"File {event.resource_id} is ready!\")\n\n@asynccontextmanager\nasync def lifespan(app):\n    yield\n    await frameio_app.close()\n\nfastapi_app = FastAPI(lifespan=lifespan)\n\n# Define your FastAPI routes BEFORE mounting\n@fastapi_app.get(\"/health\")\nasync def health():\n    return {\"status\": \"healthy\"}\n\n@fastapi_app.get(\"/metrics\")\nasync def metrics():\n    return {\"requests\": 1000}\n\n# Mount at root - handles all POST requests to \"/\"\nfastapi_app.mount(\"/\", frameio_app)\n</code></pre> <p>Route Order Matters</p> <p>When mounting at <code>/</code>, frameworks like FastAPI resolve routes in registration order. Define your application routes before mounting frameio-kit; otherwise, the mounted <code>App</code> may intercept requests that you expect to hit your own routes.</p> <p>With this setup:</p> <ul> <li>Frame.io webhooks/actions \u2192 <code>https://your-domain.com/</code></li> <li>OAuth login (if enabled) \u2192 <code>https://your-domain.com/auth/login</code></li> <li>OAuth callback (if enabled) \u2192 <code>https://your-domain.com/auth/callback</code></li> <li>Your routes remain accessible at their defined paths</li> </ul> <p>frameio-kit Middleware</p> <p>For Frame.io-specific middleware (that should only run on webhook/action handlers), use frameio-kit's built-in Middleware system instead of application-level middleware.</p>"},{"location":"usage/mounting/#running-your-application","title":"Running Your Application","text":"<p>Use <code>uvicorn</code> (or any ASGI server) to run your combined application:</p> <pre><code># Point to your application instance\nuvicorn main:fastapi_app --host 0.0.0.0 --port 8000 --reload\n</code></pre>"},{"location":"usage/mounting/#deployment-considerations","title":"Deployment Considerations","text":""},{"location":"usage/mounting/#health-checks","title":"Health Checks","text":"<p>Add a health check endpoint to monitor both your application and frameio-kit:</p> <pre><code>@fastapi_app.get(\"/health\")\nasync def health():\n    return {\"status\": \"healthy\"}\n</code></pre>"},{"location":"usage/mounting/#troubleshooting","title":"Troubleshooting","text":""},{"location":"usage/mounting/#routes-not-found","title":"Routes Not Found","text":"<p>If Frame.io events return 404:</p> <ol> <li>Verify the mount path matches your webhook/action URLs in Frame.io</li> <li>Check that you're using the correct HTTP method (<code>POST</code> for webhooks/actions)</li> <li>Ensure the mount path doesn't conflict with existing application routes or other mounted apps.</li> </ol>"},{"location":"usage/mounting/#signature-validation-fails","title":"Signature Validation Fails","text":"<p>If you get \"Invalid signature\" errors:</p> <ol> <li>Verify the secrets match the values configured in Frame.io for your webhook or custom action.</li> <li>Ensure middleware isn't modifying the request body before frameio-kit validates it</li> <li>Check that <code>X-Frameio-Request-Timestamp</code> header is being passed through</li> </ol>"},{"location":"usage/mounting/#next-steps","title":"Next Steps","text":"<ul> <li>App Configuration - Configure middleware, OAuth, and dynamic secret resolution</li> <li>Webhooks - Learn about webhook event types and best practices</li> <li>Custom Actions - Build interactive forms and workflows</li> <li>User Authentication - Enable Adobe Login OAuth for user-specific actions</li> </ul>"},{"location":"usage/user_auth/","title":"User Authentication","text":"<p>Enable Adobe Login OAuth for user-specific authentication. API calls are attributed to individual users in Frame.io's activity logs.</p>"},{"location":"usage/user_auth/#when-to-use","title":"When to Use","text":"<p>Use user authentication when you need to:</p> <ul> <li>Attribute actions to specific users in activity logs</li> <li>Access user-specific resources requiring user permissions</li> <li>Perform operations as the authenticated user</li> </ul> <p>For most integrations, server-to-server authentication is sufficient and simpler.</p>"},{"location":"usage/user_auth/#quick-start","title":"Quick Start","text":""},{"location":"usage/user_auth/#1-configure-adobe-oauth","title":"1. Configure Adobe OAuth","text":"<p>Create an OAuth credential in the Adobe Developer Console:</p> <ol> <li>Create or select a project</li> <li>Add the \"Frame.io API\" service</li> <li>Create an \"OAuth Web App\" credential</li> <li>Note your Client ID and Client Secret</li> <li>Add your callback URL: <code>https://yourapp.com/auth/callback</code></li> </ol>"},{"location":"usage/user_auth/#2-initialize-oauth","title":"2. Initialize OAuth","text":"<pre><code>import os\nfrom frameio_kit import App, OAuthConfig\n\napp = App(\n    oauth=OAuthConfig(\n        client_id=os.environ[\"ADOBE_CLIENT_ID\"],\n        client_secret=os.environ[\"ADOBE_CLIENT_SECRET\"],\n    )\n)\n</code></pre> <p>Automatic Redirect URL Inference</p> <p>By default, the OAuth callback URL is automatically inferred from incoming requests. This inference relies on proper forwarding of headers (<code>X-Forwarded-Host</code>, <code>X-Forwarded-Proto</code>) from reverse proxies or load balancers. For such deployments, you may need to set <code>redirect_url</code> explicitly. See Redirect URL Configuration.</p> <p>Token Storage</p> <p>By default, tokens are stored in memory and lost on restart. For multi-server deployments or persistence, see Storage Backends.</p>"},{"location":"usage/user_auth/#3-require-auth-in-actions","title":"3. Require Auth in Actions","text":"<pre><code>from frameio_kit import ActionEvent, Client, Message, get_user_token\n\n@app.on_action(\n    event_type=\"myapp.process_file\",\n    name=\"Process File\",\n    description=\"Process file with user credentials\",\n    secret=os.environ[\"ACTION_SECRET\"],\n    require_user_auth=True,\n)\nasync def process_file(event: ActionEvent):\n    # Get the user's token from context\n    token = get_user_token()\n\n    # Create client with user's token\n    async with Client(token=token) as user_client:\n        # Fetch the authenticated user's profile\n        profile = await user_client.users.show()\n\n        # Make API calls as the user\n        file = await user_client.files.show(\n            account_id=event.account_id,\n            file_id=event.resource_id\n        )\n\n    return Message(\n        title=\"File Processed\",\n        description=f\"Processed {file.data.name} as {profile.data.name}\"\n    )\n</code></pre>"},{"location":"usage/user_auth/#how-it-works","title":"How It Works","text":"<ol> <li>User clicks your custom action in Frame.io</li> <li>App checks for valid token</li> <li>If not authenticated, user sees \"Sign in with Adobe\" button</li> <li>User authorizes your app via Adobe Login</li> <li>Tokens are encrypted and stored</li> <li>Handler retrieves token via <code>get_user_token()</code></li> <li>Tokens automatically refresh when expired</li> </ol>"},{"location":"usage/user_auth/#configuration","title":"Configuration","text":""},{"location":"usage/user_auth/#oauthconfig-parameters","title":"OAuthConfig Parameters","text":"<ul> <li><code>client_id</code> - Adobe IMS client ID (required)</li> <li><code>client_secret</code> - Adobe IMS client secret (required)</li> <li><code>redirect_url</code> - Full OAuth callback URL (default: automatically inferred). Set explicitly for reverse proxy scenarios.</li> <li><code>scopes</code> - OAuth scopes (default: <code>[\"additional_info.roles\", \"offline_access\", \"profile\", \"email\", \"openid\"]</code>)</li> </ul>"},{"location":"usage/user_auth/#app-level-parameters","title":"App-Level Parameters","text":"<ul> <li><code>storage</code> - Token storage backend (default: <code>MemoryStorage()</code>)</li> <li><code>encryption_key</code> - Explicit encryption key (default: <code>FRAMEIO_AUTH_ENCRYPTION_KEY</code> env var or ephemeral)</li> </ul>"},{"location":"usage/user_auth/#redirect-url-configuration","title":"Redirect URL Configuration","text":"<p>Set <code>redirect_url</code> explicitly when:</p> <ul> <li>Behind a reverse proxy without proper forwarded headers</li> <li>Public URL differs from what the application sees</li> <li>Load balancer doesn't forward <code>X-Forwarded-Host</code> and <code>X-Forwarded-Proto</code> headers</li> </ul> <pre><code>app = App(\n    oauth=OAuthConfig(\n        client_id=os.environ[\"ADOBE_CLIENT_ID\"],\n        client_secret=os.environ[\"ADOBE_CLIENT_SECRET\"],\n        redirect_url=\"https://yourapp.com/auth/callback\",\n    )\n)\n</code></pre> <p>Make sure to consider mounting when setting the <code>redirect_url</code>.</p> <p>Important: Mount Path Consideration</p> <p>If you mount your app at a subpath (e.g., <code>/frameio</code>), your <code>redirect_url</code> must include the mount path. For example, if your app is mounted at <code>/frameio</code>, set: <code>redirect_url=\"https://yourapp.com/frameio/auth/callback\"</code> not <code>redirect_url=\"https://yourapp.com/auth/callback\"</code></p>"},{"location":"usage/user_auth/#complete-example","title":"Complete Example","text":"<pre><code>from frameio_kit import App, OAuthConfig, DynamoDBStorage\n\napp = App(\n    oauth=OAuthConfig(\n        client_id=os.environ[\"ADOBE_CLIENT_ID\"],\n        client_secret=os.environ[\"ADOBE_CLIENT_SECRET\"],\n        redirect_url=\"https://yourapp.com/auth/callback\",  # Explicit for proxy\n        scopes=[\"openid\", \"AdobeID\", \"frameio.api\"],\n    ),\n    storage=DynamoDBStorage(table_name=\"frameio-app-data\"),\n    encryption_key=os.environ[\"FRAMEIO_AUTH_ENCRYPTION_KEY\"],\n)\n</code></pre>"},{"location":"usage/user_auth/#storage-backends","title":"Storage Backends","text":"<p>Tokens are encrypted at rest. Choose a backend based on your deployment:</p>"},{"location":"usage/user_auth/#development-memorystorage","title":"Development: MemoryStorage","text":"<p>Tokens stored in memory (lost on restart):</p> <pre><code># Default - no storage parameter needed\napp = App(oauth=OAuthConfig(...))\n</code></pre>"},{"location":"usage/user_auth/#multi-server-dynamodbstorage","title":"Multi-Server: DynamoDBStorage","text":"<p>Install the optional dependency:</p> <pre><code>pip install frameio-kit[dynamodb]\n</code></pre> <p>Tokens shared via AWS DynamoDB:</p> <pre><code>from frameio_kit import DynamoDBStorage\n\napp = App(\n    oauth=OAuthConfig(...),\n    storage=DynamoDBStorage(table_name=\"frameio-app-data\"),\n)\n</code></pre> <p>The DynamoDB table requires a partition key <code>PK</code> (String) and TTL enabled on the <code>ttl</code> attribute.</p> <pre><code>resource \"aws_dynamodb_table\" \"frameio_app_data\" {\n  name         = \"frameio-app-data\"\n  billing_mode = \"PAY_PER_REQUEST\"\n  hash_key     = \"PK\"\n\n  attribute {\n    name = \"PK\"\n    type = \"S\"\n  }\n\n  ttl {\n    attribute_name = \"ttl\"\n    enabled        = true\n  }\n}\n</code></pre>"},{"location":"usage/user_auth/#custom-storage","title":"Custom Storage","text":"<p>Implement the <code>Storage</code> protocol for any other backend:</p> <pre><code>from frameio_kit import Storage\n\nclass RedisStorage:\n    async def get(self, key: str) -&gt; dict | None:\n        ...\n\n    async def put(self, key: str, value: dict, *, ttl: int | None = None) -&gt; None:\n        ...\n\n    async def delete(self, key: str) -&gt; None:\n        ...\n\napp = App(\n    oauth=OAuthConfig(...),\n    storage=RedisStorage(),\n)\n</code></pre>"},{"location":"usage/user_auth/#encryption","title":"Encryption","text":"<p>Tokens are encrypted using Fernet symmetric encryption. The key is loaded in priority order:</p> <ol> <li>Explicit <code>encryption_key</code> parameter on <code>App</code></li> <li>Environment variable <code>FRAMEIO_AUTH_ENCRYPTION_KEY</code></li> <li>Ephemeral key (generated on startup, lost on restart)</li> </ol>"},{"location":"usage/user_auth/#production-setup","title":"Production Setup","text":"<p>Generate and set an encryption key:</p> <pre><code># Generate key (run once)\npython -c \"from cryptography.fernet import Fernet; print(Fernet.generate_key().decode())\"\n\n# Set environment variable\nexport FRAMEIO_AUTH_ENCRYPTION_KEY=\"your-generated-key\"\n</code></pre> <p>Store this key securely (AWS Secrets Manager, HashiCorp Vault, etc.).</p>"},{"location":"usage/user_auth/#token-management","title":"Token Management","text":""},{"location":"usage/user_auth/#automatic-refresh","title":"Automatic Refresh","text":"<p>Tokens refresh automatically with a 5-minute buffer. Failed refresh deletes the token (user must re-authenticate).</p>"},{"location":"usage/user_auth/#manual-token-deletion","title":"Manual Token Deletion","text":"<pre><code># Log out a user\nawait app.token_manager.delete_token(user_id=\"user_123\")\n</code></pre>"},{"location":"usage/user_auth/#security","title":"Security","text":"<p>CSRF Protection - Random state tokens with 10-minute expiration</p> <p>Token Encryption - AES 128-bit encryption with HMAC signature</p> <p>HTTPS Required - OAuth callbacks must use HTTPS in production</p> <p>Signature Verification - Automatically handled by frameio-kit</p>"},{"location":"usage/user_auth/#mixing-authentication-methods","title":"Mixing Authentication Methods","text":"<p>Use both S2S and user auth in the same app:</p> <pre><code>app = App(\n    token=os.getenv(\"FRAMEIO_S2S_TOKEN\"),  # Server-to-server\n    oauth=OAuthConfig(...),  # User authentication\n)\n\n# S2S authentication (default)\n@app.on_action(...)\nasync def admin_action(event: ActionEvent):\n    await app.client.files.show(...)\n\n# User authentication\n@app.on_action(..., require_user_auth=True)\nasync def user_action(event: ActionEvent):\n    async with Client(token=get_user_token()) as user_client:\n        await user_client.files.show(...)\n</code></pre>"},{"location":"usage/user_auth/#troubleshooting","title":"Troubleshooting","text":"<p>\"Invalid signature\" errors</p> <ul> <li>Verify callback URL in Adobe Console matches exactly</li> </ul> <p>Tokens not persisting</p> <ul> <li>Check storage backend configuration</li> <li>Ensure encryption key consistency across restarts</li> </ul> <p>Users repeatedly asked to login</p> <ul> <li>Verify encryption key is consistent</li> <li>Check storage backend is working</li> </ul> <p>\"redirect_uri_mismatch\" error</p> <ul> <li>The inferred or configured <code>redirect_url</code> must match one registered in Adobe Developer Console</li> <li>If using automatic inference, register the callback URL you expect (e.g., <code>https://yourapp.com/auth/callback</code>)</li> <li>If behind a proxy, either configure forwarded headers or set <code>redirect_url</code> explicitly</li> </ul>"},{"location":"usage/user_auth/#next-steps","title":"Next Steps","text":"<ul> <li>Custom Actions - Learn about building interactive workflows</li> <li>Client API - Understand API authentication patterns</li> <li>API Reference - Detailed OAuth types documentation</li> </ul>"},{"location":"usage/webhooks/","title":"Webhooks","text":"<p>Webhooks are automated, non-interactive messages sent from Frame.io to your application when specific events occur. They're perfect for building reactive workflows that respond to changes in real-time without user intervention.</p>"},{"location":"usage/webhooks/#why-use-webhooks","title":"Why Use Webhooks?","text":"<p>Webhooks are ideal when you need to:</p> <ul> <li>React to file changes (uploads, processing completion, etc.)</li> <li>Monitor project activity (comments, approvals, status changes)</li> <li>Trigger automated workflows (notifications, data processing, integrations)</li> <li>Keep external systems in sync with Frame.io events</li> <li>Build event-driven applications that respond to Frame.io activity</li> </ul>"},{"location":"usage/webhooks/#how-webhooks-work","title":"How Webhooks Work","text":"<ol> <li>Event occurs in Frame.io (file uploaded, comment added, etc.)</li> <li>Frame.io sends HTTP POST to your configured webhook URL</li> <li>Your handler processes the event data</li> </ol> <pre><code>Frame.io Event \u2192 HTTP POST \u2192 Your Handler\n</code></pre>"},{"location":"usage/webhooks/#webhook-decorator","title":"Webhook Decorator","text":"<p>Use the <code>@app.on_webhook</code> decorator to register handlers:</p> <pre><code>import os\n\n# Single webhook - use default WEBHOOK_SECRET env var\n@app.on_webhook(event_type=\"file.ready\")\nasync def on_file_ready(event: WebhookEvent):\n    # Handle the event\n    pass\n\n# Multiple webhooks with different secrets - use explicit env vars\n@app.on_webhook(event_type=\"file.ready\", secret=os.environ[\"FILE_READY_WEBHOOK_SECRET\"])\nasync def on_file_ready(event: WebhookEvent):\n    pass\n\n@app.on_webhook(event_type=\"comment.created\", secret=os.environ[\"COMMENTS_WEBHOOK_SECRET\"])\nasync def on_comment_created(event: WebhookEvent):\n    pass\n</code></pre>"},{"location":"usage/webhooks/#parameters","title":"Parameters","text":"<ul> <li><code>event_type</code> (str | list[str]): The event name(s) to listen for</li> <li><code>secret</code> (str | None, optional): The signing secret from Frame.io. If not provided, falls back to the <code>WEBHOOK_SECRET</code> environment variable. Explicit parameter takes precedence over environment variable.</li> </ul> <p>Environment Variables</p> <p>Single webhook: Use the default <code>WEBHOOK_SECRET</code> environment variable and omit the <code>secret</code> parameter.</p> <p>Multiple webhooks with different secrets: Pass each secret explicitly via <code>secret=os.environ[\"WEBHOOK_NAME_WEBHOOK_SECRET\"]</code> to keep secrets out of your code while supporting multiple webhook configurations.</p>"},{"location":"usage/webhooks/#webhook-event-object","title":"Webhook Event Object","text":"<p>The <code>WebhookEvent</code> object provides typed access to all event data:</p> <pre><code>from frameio_kit import WebhookEvent\n\nasync def handler(event: WebhookEvent):\n    print(event.type)           # \"file.ready\"\n    print(event.resource_id)    # \"abc123\"\n    print(event.account_id)     # \"acc_456\"\n    print(event.user_id)        # \"user_789\"\n    print(event.project_id)     # \"proj_101\"\n    print(event.workspace_id)   # \"ws_123\"\n</code></pre>"},{"location":"usage/webhooks/#event-types","title":"Event Types","text":"<p>See Webhook Event Subscriptions for the full list of event types.</p>"},{"location":"usage/webhooks/#example-1-single-webhook-default-env-var","title":"Example 1: Single Webhook (Default Env Var)","text":"<pre><code>from frameio_kit import App, WebhookEvent, Message\n\napp = App()\n\n# Single webhook - WEBHOOK_SECRET env var used automatically\n@app.on_webhook(\"file.ready\")\nasync def on_file_ready(event: WebhookEvent):\n    print(f\"File {event.resource_id} is ready for processing\")\n\n    # Simulate some processing\n    await process_file(event.resource_id)\n\nasync def process_file(file_id: str):\n    # Your processing logic here\n    pass\n</code></pre>"},{"location":"usage/webhooks/#example-2-multiple-webhooks-explicit-env-vars","title":"Example 2: Multiple Webhooks (Explicit Env Vars)","text":"<pre><code>import os\nfrom frameio_kit import App, WebhookEvent\n\napp = App()\n\n# Multiple webhooks with different secrets - use explicit env vars\n@app.on_webhook(event_type=\"file.ready\", secret=os.environ[\"FILE_READY_WEBHOOK_SECRET\"])\nasync def on_file_ready(event: WebhookEvent):\n    print(f\"File ready: {event.resource_id}\")\n    await process_file(event.resource_id)\n\n@app.on_webhook(event_type=\"comment.created\", secret=os.environ[\"COMMENT_CREATED_WEBHOOK_SECRET\"])\nasync def on_comment_created(event: WebhookEvent):\n    print(f\"New comment: {event.resource_id}\")\n    await notify_team(event)\n\n@app.on_webhook(event_type=\"comment.updated\", secret=os.environ[\"COMMENT_UPDATED_WEBHOOK_SECRET\"])\nasync def on_comment_updated(event: WebhookEvent):\n    print(f\"Updated comment: {event.resource_id}\")\n    await notify_team(event)\n</code></pre>"},{"location":"usage/webhooks/#example-3-using-the-api-client","title":"Example 3: Using the API Client","text":"<pre><code>import os\nfrom frameio import CreateCommentParamsData\nfrom frameio_kit import App, WebhookEvent, Message\n\napp = App(token=os.getenv(\"FRAMEIO_TOKEN\"))\n\n# Single webhook - use default WEBHOOK_SECRET\n@app.on_webhook(\"file.ready\")\nasync def add_processing_comment(event: WebhookEvent):\n    # Use the API client to add a comment back to Frame.io\n    await app.client.comments.create(\n        account_id=event.account_id,\n        file_id=event.resource_id,\n        data=CreateCommentParamsData(text=\"File has been automatically processed!\")\n    )\n</code></pre>"},{"location":"usage/webhooks/#dynamic-secret-resolution","title":"Dynamic Secret Resolution","text":"<p>When you need to resolve webhook secrets dynamically (e.g., from a database for multi-tenant applications), use secret resolvers.</p>"},{"location":"usage/webhooks/#decorator-level-resolver","title":"Decorator-Level Resolver","text":"<p>Provide an async function that receives the <code>WebhookEvent</code> and returns the secret:</p> <pre><code>from frameio_kit import App, WebhookEvent\n\napp = App()\n\nasync def resolve_webhook_secret(event: WebhookEvent) -&gt; str:\n    \"\"\"Resolve secret based on account ID.\"\"\"\n    return await db.get_webhook_secret(account_id=event.account_id)\n\n# Use the resolver for this specific webhook\n@app.on_webhook(\"file.ready\", secret=resolve_webhook_secret)\nasync def on_file_ready(event: WebhookEvent):\n    print(f\"File {event.resource_id} is ready\")\n</code></pre>"},{"location":"usage/webhooks/#secret-resolution-precedence","title":"Secret Resolution Precedence","text":"<ol> <li>Explicit string secret (<code>secret=\"...\"</code>)</li> <li>Decorator-level resolver (<code>secret=my_resolver</code>)</li> <li>Install system resolver (when <code>install=True</code>, secrets are auto-managed)</li> <li>Environment variable (<code>WEBHOOK_SECRET</code>)</li> </ol>"},{"location":"usage/webhooks/#setting-up-webhooks-in-frameio","title":"Setting Up Webhooks in Frame.io","text":"<p>See Webhook Tutorial for instructions on how to set up webhooks in Frame.io.</p>"},{"location":"usage/webhooks/#best-practices","title":"Best Practices","text":"<ol> <li>Handle errors gracefully - Webhook failures can cause retries</li> <li>Keep handlers fast - Long-running operations should be queued, Frame.io expects a response within 5 seconds</li> <li>Handle retries - Non-2xx or slow responses will cause Frame.io to retry the request up to 5 times (initial + 4 retries)</li> <li>Log webhook events for debugging and monitoring</li> </ol>"},{"location":"usage/webhooks/#security-considerations","title":"Security Considerations","text":"<ul> <li>Use HTTPS for your webhook endpoints</li> <li>Validate event data before processing</li> <li>Implement rate limiting to prevent abuse</li> <li>Monitor for suspicious activity and unexpected payloads</li> </ul>"}]}