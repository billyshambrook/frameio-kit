"""App manifest generation with auto-discovery of handlers.

This module provides automatic discovery of registered action and webhook handlers
to generate an installation manifest.
"""

import hashlib
from typing import TYPE_CHECKING

from pydantic import BaseModel, Field

if TYPE_CHECKING:
    from ._app import App


class ActionManifestItem(BaseModel):
    """Manifest entry for a custom action.

    Attributes:
        event_type: The event type identifier (e.g., "my_app.transcribe").
        name: Display name for the action.
        description: Description of what the action does.
        require_user_auth: Whether this action requires user authentication.
    """

    event_type: str
    name: str
    description: str
    require_user_auth: bool = False


class WebhookManifestItem(BaseModel):
    """Manifest entry for a webhook.

    Attributes:
        event_types: List of event types this webhook listens to.
        description: Description of what this webhook does.
    """

    event_types: list[str]
    description: str = "Webhook event handler"


class AppManifest(BaseModel):
    """Complete manifest of an app's actions and webhooks.

    This manifest is auto-generated by discovering registered handlers
    and is used during installation to create resources in Frame.io.

    Attributes:
        name: App name.
        description: App description.
        icon_url: Optional URL to app icon.
        base_url: Base URL of the app.
        actions: List of custom actions to install.
        webhooks: List of webhooks to install.
    """

    name: str
    description: str
    icon_url: str | None = None
    base_url: str
    actions: list[ActionManifestItem] = Field(default_factory=list)
    webhooks: list[WebhookManifestItem] = Field(default_factory=list)

    @classmethod
    def from_app(
        cls,
        app: "App",
        app_name: str,
        app_description: str,
        base_url: str,
        icon_url: str | None = None,
        include_actions: list[str] | None = None,
        include_webhooks: list[str] | None = None,
    ) -> "AppManifest":
        """Generate manifest by auto-discovering registered handlers.

        Args:
            app: The App instance to discover handlers from.
            app_name: Display name for the app.
            app_description: Description of the app.
            base_url: Base URL of the app.
            icon_url: Optional URL to app icon.
            include_actions: Optional list of action event_types to include. None means all.
            include_webhooks: Optional list of webhook event_types to include. None means all.

        Returns:
            Complete AppManifest with discovered handlers.
        """
        actions: list[ActionManifestItem] = []
        webhooks: list[WebhookManifestItem] = []

        # Discover actions
        for event_type, registration in app._action_handlers.items():
            # Filter if include list provided
            if include_actions is not None and event_type not in include_actions:
                continue

            actions.append(
                ActionManifestItem(
                    event_type=event_type,
                    name=registration.name or event_type,
                    description=registration.description or "",
                    require_user_auth=registration.require_user_auth,
                )
            )

        # Discover webhooks - group by unique event types
        # Webhooks can be registered multiple times for different event types
        webhook_event_types: set[str] = set()
        for event_type in app._webhook_handlers.keys():
            # Filter if include list provided
            if include_webhooks is not None and event_type not in include_webhooks:
                continue
            webhook_event_types.add(event_type)

        # Create a single webhook entry with all event types
        if webhook_event_types:
            webhooks.append(
                WebhookManifestItem(
                    event_types=sorted(list(webhook_event_types)),
                    description=f"Handles {len(webhook_event_types)} webhook event type(s)",
                )
            )

        return cls(
            name=app_name,
            description=app_description,
            icon_url=icon_url,
            base_url=base_url,
            actions=actions,
            webhooks=webhooks,
        )

    def compute_hash(self) -> str:
        """Compute a hash of this manifest for version tracking.

        Returns:
            SHA256 hash of the manifest content.
        """
        # Create a stable string representation
        content = f"{self.name}|{self.description}|"
        content += "|".join(f"{a.event_type}:{a.name}:{a.description}" for a in self.actions)
        content += "|"
        content += "|".join(f"{','.join(w.event_types)}:{w.description}" for w in self.webhooks)

        return hashlib.sha256(content.encode()).hexdigest()[:16]
